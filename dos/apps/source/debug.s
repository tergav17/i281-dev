; DEBUG.S
; MODIFY A .SAV RECORD

; BANK ALLOCATION STUFF
BI	= 1
BD	= 1

; MAXIMUM ARGUMENTS
MAXARGS	= 1

.TEXT
.BANK	BI
CORE0_B	= BI

	; START BY PROCESSING THE ARGUMENTS
START:	LOADI	A,0
	STORE	[DBANK],A
	
	; RESET ARG STATE
	STORE	[ARGC],A
	
	; SET UP STACK
	LOADI	D,0X60-2
	
	; SYSCALL RETURN BANK
	LOADI	C,1	
	STOREF	[D+1],C
	
	; SET UP POINTER
	LOADI	C,0
	
	; GO TO ARGUMENT BANK
0:	LOAD	A,[CMDL_B]
	STORE	[ARG_BNK],A
	STORE	[DBANK],A

	; SKIP THE CURRENT ARGUMENT
1:	LOADF	A,[C]
	LOADI	B,0X20
	CMP	A,B
	BRBE	2F
	ADDI	C,1
	JUMP	1B

	; LOOK FOR AN ARGUMENT
2:	LOADF	A,[C]
	ADDI	A,0
	BRZ	ARGDONE
	CMP	A,B
	BRA	3F
	ADDI	C,1
	JUMP	2B

	; IS IT A FLAG?
3:	LOADI	B,'-'
	CMP	A,B
	BRNZ	5F
	
	; HANDLE FLAGS HERE	
4:	ADDI	C,1
	LOADF	A,[C]
	ADDI	A,0
	BRZ	ARGDONE
	LOADI	B,0X20
	CMP	A,B
	BRBE	2B
	
	; REGISTER THE FLAG
	LOADI	B,0
	STORE	[DBANK],B

;	SUBI	A,'A'
;	BRNZ	@+2
;	LOADI	B,AFLAG
	
	; IS IT A RECOGNIZED FLAG?
	ADDI	B,0
	BRZ	ARGBAD
	LOADI	A,1
	STOREF	[B],A

	; THERE MAY BE ANOTHER FLAG
	LOAD	B,[CMDL_B]
	STORE	[ARG_BNK],B
	STORE	[DBANK],B
	JUMP	4B

	; SAVE THE ARGUMENT
5:	LOADI	B,0
	STORE	[DBANK],B
	LOAD	B,[ARGC]
	STOREF	[B+ARGV],C
	
	; DID WE EXCEED THE ALLOWED NUMBER OF ARGUMENTS
	SUBI	B,MAXARGS
	BRC	ARGBAD
	ADDI	B,MAXARGS+1
	STORE	[ARGC],B
	JUMP	0B
	
	; BAD ARGUMENT
ARGBAD:	LOADI	A,0
	STORE	[DBANK],A
	
	LOADI	A,STR0_B
	STORE	[ARG_BNK],A
	LOADI	A,ERROR0
	
	; PRINT ERROR MESSAGE
	LOADI	B,S_PUTS
	LOADI	C,EXIT
	JUMP	SYSCALL	

	; EXIT PROGRAM
EXIT:	LOADI	B,0
	JUMP	SYSJUMP
	
	; ARGUMENT PROCESSING DONE
ARGDONE:LOADI	A,0
	STORE	[DBANK],A
	
	; CHECK ARG COUNT
	LOAD	A,[ARGC]
	SUBI	A,1
	BRNZ	ARGBAD
	
	; GO TO PROMPT
	LOADI	B,CMD0_B
	LOADI	C,PROMPT
	JUMP	INDIR
	
	JUMP	EXIT


	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
.TEXT
.BANK	BI
CMD0_B	= BI

ERROR:	LOADI	A,ST_ERR
	JUMP	0F

	; SEND UP THE COMMAND LINE PROMPT
PROMPT:	LOADI	A,ST_PRM
0:	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,STR0_B
	STORE	[ARG_BNK],B
	LOADI	B,S_PUTS
	LOADI	C,@+2
	JUMP	SYSCALL
	
	; GET USER INPUT
	LOADI	B,BUF_B
	STORE	[ARG_BNK],B
	LOADI	B,S_INPUT
	LOADI	C,@+2
	JUMP	SYSCALL

	; PREPARE TO PARSE
	LOADI	A,0
	STORE	[POINTER],A
	STORE	[STATE],A
	STORE	[ADDRESS],A
	
	; EXECUTE PARSE
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,CMD0_B
	LOADI	C,PARSEH
	JUMP	INDIR
	ADDI	A,0
	BRN	ERROR
	
	; MAKE SURE THE NEXT VALUE IS ZERO
	LOAD	C,[POINTER]
	LOADI	B,BUF_B
	STORE	[DBANK],B
	LOADF	C,[C+1]
	LOADI	B,0
	STORE	[DBANK],B
	ADDI	C,0
	BRNZ	ERROR
	
	; PARSE COMMAND
	SUBI	A,'Q'
	LOADI	B,CORE0_B
	LOADI	C,EXIT
	BRZ	INDIR
	
	JUMP	ERROR
	
	; PARSES A HEXADECIMAL NUMBER
	; THE NUMBER WILL CONTINUE TO BE PARSED UNTIL
	; THE END OF THE NUMBER IS REACHED.
	; [POINTER] = ADDRESS OF NUMBER
	; RETURNS A=0XFF IF THE PARSING OVERFLOWED
	; USES: A, B, C
PARSEH:	LOADI	A,0
	STORE	[VALUE],A
	STORE	[VALUE+1],A

	; READ A CHARACTER FROM THE COMMAND LINE
0:	LOAD	C,[POINTER]
	LOADI	B,BUF_B
	STORE	[DBANK],B
	LOADF	A,[C]
	LOADI	B,0
	STORE	[DBANK],B
	ADDI	C,1
	STORE	[POINTER],C
	
	; CHECK BOUNDS
	LOADI	B,'0'
	CMP	A,B
	BRB	IRET
	LOADI	B,'9'
	CMP	A,B
	BRBE	1F
	
	LOADI	B,'A'
	CMP	A,B
	BRB	IRET
	LOADI	B,'F'
	CMP	A,B
	BRA	IRET
	
	SUBI	A,'A'-('0'+10)
	
	; CONVERT FROM ASCII
1:	SUBI	A,'0'

	; MULTIPLY VALUE BY 4
	STORE	[TEMP],A
	LOAD	B,[VALUE]
	LOAD	C,[VALUE+1]
	LOADI	A,4
2:	SHIFTL	B
	BRC	9F
	SHIFTL	C
	BRNC	3F
	ADDI	B,1
3:	SUBI	A,1
	BRNZ	2B
	
	; ADD TO VALUE
	LOAD	A,[TEMP]
	ADD	C,A
	STORE	[VALUE],B
	STORE	[VALUE+1],C
	
	; SET STATE
	LOADI	A,1
	STORE	[STATE],A
	JUMP	0B
	
	; ERROR
9:	LOADI	A,0XFF
	JUMP	IRET

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
.TEXT
.BANK	BI
FIO_B	= BI

	; READS IN THE INITIAL SAVE FILE
	; IF A RECORD IS FOUND, THE BLOCK WILL BE RECORDED
	; CLEAR THE ALLOCATION TABLE
SVREAD:	LOADI	A,0
	LOADI	C,0
0:	LOADI	B,ALLOC_B
	STORE	[DBANK],B
	STOREF	[C],A
	LOADI	B,ALLOC_B+1
	STORE	[DBANK],B
	STOREF	[C],A
	ADDI	C,1
	BRNN	0B
	STORE	[DBANK],A
	
	; ATTEMPT TO OPEN FILE
	LOAD	A,[CMDL_B]
	STORE	[ARG_BNK],A
	LOAD	A,[ARGV]
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,S_OPEN
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	BRZ	1F
	
	; CAN'T OPEN, CREATE THE FILE
	LOADI	B,S_CREAT
	LOADI	C,@+2
	JUMP	SUSCALL
	ADDI	A,0
	BRZ	1F
	
	; ERROR
	LOADI	A,ERROR1
	JUMP	9F
	
	; RESET BLOCK COUNTER
1:	LOADI	A,WORK_B
	STORE	[ARG_BNK],A
	LOADI	A,0
	
	; READ A BLOCK
2:	STORE	[FNEXT],A
	LOADI	B,S_READ
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	BRNZ	4F
	
	; CHECK BLOCK
	LOAD	C,[FNEXT]
	LOADI	A,ERROR3
	LOADI	B,WORK_B
	STORE	[DBANK],B
	LOAD	B,[0]
	SUBI	B,0X02
	BRNZ	9F
	LOAD	B,[1]
	SUBI	B,0X81
	BRNZ	9F
	
	; GRAB BANK #
	LOAD	A,[2]
	LOADI	B,BTAB_B
	SHIFTL	C
	BRNC	3F
	ADDI	B,1
3:	SHIFTR	C
	STORE	[DBANK],B
	STOREF	[C],A
	
	; ERROR OUT!
9:	LOADI	B,CORE0_B
	STOREF	[D+1],B
	LOADI	B,STR0_B
	STORE	[ARG_BNK],B
	LOADI	B,S_PUTS
	LOADI	C,EXIT
	JUMP	SYSCALL


.DATA
.BANK	BD
STR0_B	= BD

	; ERROR MESSAGES
.DEFL BYTE ERROR0	"INVALID ARGUMENTS",0X0A,0X0D,
			"USAGE: DEBUG FILE",0X0A,0X0D,0
.DEFL BYTE ERROR1	"CAN'T CREATE FILE",0X0A,0X0D,0
.DEFL BYTE ERROR2	"OUT OF SPACE",0X0A,0X0D,0
.DEFL BYTE ERROR3	"BAD RECORD"
.DEFL BYTE CRLF		0X0A,0X0D,0

.DEFL BYTE ST_ERR	0X0A,0X0D,"?"
.DEFL BYTE ST_PRM	0X0A,0X0D,"*",0

	; ZERO BANK STUFF
.BANK	0
.BSS

	; COMMAND LINE ARGUMENTS
.DEFL BYTE ARGC		0
.DEFL BYTE ARGV		0,0

	; PARSE STATE
.DEFL BYTE POINTER	0
.DEFL BYTE STATE	0
.DEFL BYTE VALUE	0,0

	; BLOCK EDIT STATE
.DEFL BYTE CBLOCK	0
.DEFL BYTE DIRTY	0
.DEFL BYTE ADDRESS	0
.DEFL BYTE FNEXT	0

	; STACK PARKING SPACE
.DEFL BYTE SPARK	0

	; TEMPORARY VALUE
.DEFL BYTE TEMP		0

BD	= BD+1
.DATA
.BANK	BD
BUF_B	= BD

	; GENERAL PURPOSE BUFFER
	
BD	= BD+1
.DATA
.BANK	BD
BTAB_B	= BD
BD	= BD+1

	; BLOCK ADDRESS TABLE
	; TURNS A LOGIC SAV BLOCK INTO A PHYSICAL FILE BLOCK

BD	= BD+1
.DATA
.BANK	BD
ALLOC_B	= BD
BD	= BD+1

	; BLOCK ALLOCATION TABLE
	; MARKS IF A LOGICAL SAV BLOCK HAS BEEN ALLOCATED YET
	
BD	= BD+1
.DATA
.BANK	BD
WORK_B	= BD
BD	= BD+3

	; WORK BANK
	; WORK_B + 0 = RECORD HEADER
	; WORK_B + 1 = DATA SEGMENT
	; WORK_B + 2 = ISR SEGMENT 128-191
	; WORK_B + 3 = ISR SEGMENT 192-255