; ED0.S
; SIMPLE TEXT EDITOR
; USER INTERFACE AND MEMORY MANAGEMENT
; GAVIN TERSTEEG, 2024
; SDMAY24-14

; BANK ALLOCATION STUFF
BI	= 1
BD	= 1

.TEXT
.BANK	BI
CORE0_B	= BI

	; START BY PROCESSING THE ARGUMENTS
START:	LOADI	A,0
	STORE	[DBANK],A
	
	; SET UP STACK
	LOADI	D,0X60-2
	
	; SYSCALL RETURN BANK
	LOADI	C,BI
	STOREF	[D+1],C
	
	; SAVE STACK
	STORE	[SPARK],D
	
	; GO TO ARGUMENT BANK
	LOAD	A,[CMDL_B]
	STORE	[ARG_BNK],A
	STORE	[DBANK],A
	
	; SET UP POINTER
	LOADI	C,0
	
	; SKIP THE INITIAL COMMAND
0:	LOADF	A,[C]
	LOADI	B,0X20
	CMP	A,B
	BRBE	1F
	ADDI	C,1
	JUMP	0B

	; LOOK FOR THE FIRST ARGUMENT
1:	LOADF	A,[C]
	ADDI	A,0
	BRZ	2F
	CMP	A,B
	BRA	OPENARG
	ADDI	C,1
	JUMP	1B
	
	; NO ARGUMENT, EMPTY BUFFER
2:	LOADI	A,0
	STORE	[DBANK],A
	
	; INIT MEMORY
	LOADI	C,9F
	STOREF	[D],C
	LOADI	B,MEM0_B
	LOADI	C,MINIT
	JUMP	INDIR
	
	; JUMP TO COMMAND LINE

	
	; THERE IS AN ARG, TRY AND OPEN IT
OPENARG:LOADI	D,FNAME
0:	LOADF	A,[C]
	LOADI	B,0
	STORE	[DBANK],B
	STOREF	[D],A
	SUBI	A,0X20
	BRBE	1F
	ADDI	C,1
	ADDI	D,1
	LOADI	B,FNAME+15
	CMP	D,B
	BRAE	1F
	LOAD	B,[CMDL_B]
	STORE	[DBANK],B
	JUMP	0B
	
	; TERMINATE STRING AND OPEN FILE
1:	LOADI	A,0
	STOREF	[D],A
	LOAD	D,[SPARK]
	
	; OPEN THE FILE
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,FIO0_B
	LOADI	C,FREAD
	JUMP	INDIR

	; CHECK ERROR STATUS
	ADDI	A,0
	BRZ	9F
	
	; INIT MEMORY
	LOADI	C,9F
	STOREF	[D],C
	LOADI	B,MEM0_B
	LOADI	C,MINIT
	JUMP	INDIR
	
	; ERROR!
	LOADI	B,CMD0_B
	LOADI	C,ERROR
	JUMP	INDIR

	; MEMORY SETUP IS DONE
	; SEND UP THE COMMAND PROMPT
9:	LOADI	B,CMD0_B
	LOADI	C,PROMPT
	JUMP	INDIR

	; EXIT PROGRAM
DONE:	LOADI	B,S_EXIT
	JUMP	SYSJUMP
	
	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
.TEXT
.BANK	BI
CMD0_B	= BI

ERROR:	LOADI	A,ST_ERR
	JUMP	0F

	; SEND UP THE COMMAND LINE PROMPT
PROMPT:	LOADI	A,ST_PRM
0:	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,STR0_B
	STORE	[ARG_BNK],B
	LOADI	B,S_PUTS
	LOADI	C,@+2
	JUMP	SYSCALL
	
	; GET USER INPUT
	LOADI	B,BUF_B
	STORE	[ARG_BNK],B
	LOADI	B,S_INPUT
	LOADI	C,@+2
	JUMP	SYSCALL
	
	; BEGIN COMMAND PROCESSING
	LOADI	A,0
	STORE	[POINTER],A
	STORE	[STATE],A
	
	; START PROCESSING A NUMBER (MAYBE?)
0:	LOAD	A,[ARGA]
	LOAD	B,[ARGA+1]
	STORE	[ARGB],A
	STORE	[ARGB+1],B
	LOADI	A,0
	STORE	[ARGA],A
	STORE	[ARGA+1],A

	; READ A CHARACTER FROM THE COMMAND LINE
1:	LOAD	A,[POINTER]
	LOADI	B,BUF_B
	STORE	[DBANK],B
	LOADF	C,[A]
	LOADI	B,0
	STORE	[DBANK],B
	ADDI	A,1
	STORE	[POINTER],A
	
	; CHECK CHARACTER
	LOADI	A,','
	CMP	C,A
	BRZ	8F
	LOADI	A,'0'
	CMP	C,A
	BRB	ERROR
	LOADI	A,'9'
	CMP	C,A
	BRA	9F
	
	; MAKE SURE STATE ISN'T 0
	LOAD	A,[STATE]
	ADDI	A,0
	BRNZ	2F
	LOADI	A,1
	STORE	[STATE],A
	
	; MULTIPLY ARG A BY 10
2:	STORE	[CHAR],C
	LOADI	C,9
	LOAD	A,[ARGA]
	LOAD	B,[ARGA+1]
	STORE	[TEMP],A
	STORE	[TEMP+1],B
3:	LOAD	A,[TEMP+1]
	LOAD	B,[ARGA+1]
	ADD	B,A
	STORE	[ARGA+1],B
	LOAD	A,[TEMP]
	LOAD	B,[ARGA]
	BRNC	4F
	ADDI	B,1
	BRC	ERROR 
4:	ADD	B,A
	BRC	ERROR 
	STORE	[ARGA],B
	SUBI	C,1
	BRNZ	3B
	LOAD	C,[CHAR]
	
	; ADD THE NUMBER
	SUBI	C,'0'
	LOAD	A,[ARGA+1]
	ADD	A,C
	STORE	[ARGA+1],A
	BRNC	5F
	LOAD	A,[ARGA]
	ADDI	A,1
	STORE	[ARGA],A
	BRC	ERROR 
	
5:	JUMP	1B
	
	; PROCESS COMMA
8:	LOAD	A,[STATE]
	SUBI	A,1
	BRN	ERROR
	BRNZ	ERROR
	LOADI	A,2
	STORE	[STATE],A
	JUMP	0B

	; PROCESS COMMAND
9:	MOV	A,C

	; QUIT?
	LOADI	B,'Q'
	CMP	A,B
	LOADI	B,S_EXIT
	BRZ	SYSJUMP
	
	; CHANGE FILE?
	LOADI	B,'F'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,SETFILE
	BRZ	INDIR
	
	; MAKE SURE COMMAND IS ZERO TERMINATED
	LOAD	C,[POINTER]
	LOADI	B,BUF_B
	STORE	[DBANK],B
	LOADF	C,[C]
	LOADI	B,0
	STORE	[DBANK],B
	ADDI	C,0
	BRNZ	ERROR
	
	LOADI	B,CMD1_B
	LOADI	C,PROCMD
	JUMP	INDIR
	
	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
.TEXT
.BANK	BI
CMD1_B	= BI

	; PROCESS STANDARD COMMAND
PROCMD:	LOADI	B,'P'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,PRINTL
	BRZ	INDIR
	
	LOADI	B,'N'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,PRINTN
	BRZ	INDIR
	
	; READ FILE
	LOADI	B,'R'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,DOFREAD
	BRZ	INDIR
	
	; READ FILE
	LOADI	B,'W'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,DOFWRIT
	BRZ	INDIR
	
	; APPEND LINES
	LOADI	B,'A'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,APPEND
	BRZ	INDIR
	
	; INSERT LINES
	LOADI	B,'I'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,INSERT
	BRZ	INDIR
	
	; DELETE LINES
	LOADI	B,'D'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,DELETE
	BRZ	INDIR
	
	; MEMORY COUNT
	LOADI	B,'M'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,PFREE
	BRZ	INDIR
	
	; LINE COUNT
	LOADI	B,'L'
	CMP	A,B
	LOADI	B,UOP0_B
	LOADI	C,PLINES
	BRZ	INDIR
	
	; CAN'T FIND COMMAND
	LOADI	B,CMD0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
	; GO BACK TO COMMAND LINE
9:	LOADI	B,CMD0_B
	LOADI	C,PROMPT
	JUMP	INDIR

		; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
	
	; ZERO BANK
.BANK	0
.BSS

	; CURRENT BLOCK OF MEMORY TO WORK ON
.DEFL BYTE CBLOCK	0,0

	; BLOCK TO BE LINKED ONTO THE CURRENT BLOCK
.DEFL BYTE LBLOCK	0,0

	; MISC CONTEXT INFORMATION
.DEFL BYTE BLOCK	0
.DEFL BYTE BANK		0
.DEFL BYTE POINTER	0

	; MEMORY BLOCK PARSE INFORMATION
.DEFL BYTE MB_PNTR	0
.DEFL BYTE MB_END	0

	; FIRST CHARACTER?
.DEFL BYTE FIRST	0

	; CURRENT CHARACTER
.DEFL BYTE CHAR		0

	; LINE COUNT
.DEFL BYTE LINES	0

	; STACK PARKING SPACE
.DEFL BYTE SPARK	0

	; FREE MEMORY TABLE
.DEFL BYTE FREETAB	0,0

	; DO LINE NUMBER?
.DEFL BYTE DOLINEN	0

	; LINE EDITOR CONTENT
.DEFL BYTE LINETAB	0,0

	; STATE FOR COMMAND PROCESSING
.DEFL BYTE STATE	0

	; LINE NUMBER ARGUMENTS FOR COMMANDS
.DEFL BYTE ARGA		0,0
.DEFL BYTE ARGB		0,0
.DEFL BYTE TEMP		0,0

	; CURRENT FILE NAME
.DEFL BYTE FNAME	0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0

	; PREVIOUS BLOCK
	; ONLY UPDATED WHEN USING FINDL
.DEFL BYTE PBLOCK	0,0

	; NUMBER OF BLOCKS FREE
.DEFL BYTE NUMFREE	0,0

	; PADDING FOR DECIMAL NUMBER PRINT
.DEFL BYTE PADDING	0

	; RETURN FOR LEAF FUNCTIONS
.DEFL BYTE LEAFRET	0

	; START OF DEFINED MEMORY
.BANK	BD
.DATA
STR0_B = BD	; STRING BANK

	; ERROR MESSAGE / PROMPT
.DEFL BYTE ST_ERR	0X0A,0X0D,'?'
.DEFL BYTE ST_PRM	0X0A,0X0D,'%',0

	; BANK IS DONE, MOVE ON TO THE NEXT
BD	= BD+1
BUF_B	= BD	; BUFFER BANK

	; BANK IS DONE, MOVE ON TO THE NEXT
BD	= BD+4
HEAP	= BD	; THE REST OF MEMORY IS HEAP

