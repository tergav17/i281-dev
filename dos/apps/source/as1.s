; AS1.S
; ASSEMBLER MAIN LOGIC
; GAVIN TERSTEEG, 2024
; SDMAY24-14

BI	= BI+1
.TEXT
.BANK	BI
MAIN0_B	= BI

	; START A PASS
	; BEGIN BY REWINDING THE SOURCE STREAM
DOPASS:	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,REWIND
	JUMP	INDIR
	
	; RESET EMIT STATE
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,EMPASS
	JUMP	INDIR
	
	; SET SEGMENT TO TEXT
	LOADI	A,0
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,SETSEG
	JUMP	INDIR
	
	; RESET LOCAL COUNTER
	LOADI	A,0
	STORE	[NUMLOC],A
	STORE	[NUMLOC+1],A

	; TAKE IN A NEW LINE OF SOURCE CODE
ASMLINE:LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	
	; ARE WE AT THE END?
	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	ASMDONE
	
	; IS IT NEWLINE?
	SUBI	A,NEWLINE
	BRZ	ASMLINE
	
	; IS IT A SYMBOL?
	SUBI	A,SYMBOL-NEWLINE
	LOADI	B,MAIN1_B
	LOADI	C,ASMSYM
	BRZ	INDIR
	
	; IS IT A NUMERIC?
	SUBI	A,NUMERIC-SYMBOL
	LOADI	B,MAIN2_B
	LOADI	C,ASMNUM
	BRZ	INDIR
	
	; IS IT A DIRECTIVE?
	SUBI	A,'.'-NUMERIC
	LOADI	B,MAIN3_B
	LOADI	C,ASMDIR
	BRZ	INDIR
	
	; I HAVE NO IDEA
	LOADI	A,E_UXTOK
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	BRNZ	INDIR
	
	; DO WE HAVE ANOTHER PASS?
ASMDONE:LOAD	A,[PASS]
	ADDI	A,0
	BRNZ	0F
	ADDI	A,1
	STORE	[PASS],A
	JUMP	DOPASS
	
	; ONE FINAL CALL TO SETBANK TO MAKE SURE ALL BUFFER IS PURGED
0:	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,SETBANK
	JUMP	INDIR

	; EXIT
	LOADI	B,CORE0_B
	LOADI	C,EXIT
	JUMP	INDIR
	
BI	= BI+1
.TEXT
.BANK	BI
MAIN1_B	= BI
	
	; LINE STARTS WITH A SYMBOL
	; STORE SYMBOL IN INSTRUCTION NAME BUFFERS
	; I SWEAR THIS IS FASTER
ASMSYM:	LOADI	A,7
0:	LOADI	B,TBUF
	ADD	B,A
	LOADF	B,[B]
	LOADI	C,ITAB0_B
	STORE	[DBANK],C
	STOREF	[A],B
	LOADI	C,ITAB1_B
	STORE	[DBANK],C
	STOREF	[A],B
	LOADI	C,ITAB2_B
	STORE	[DBANK],C
	STOREF	[A],B
	LOADI	C,0
	STORE	[DBANK],C
	SUBI	A,1
	BRNN	0B
	
	; GRAB NEXT TOKEN
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; IS IT A '=' TOKEN?
	LOAD	A,[TOKEN]
	SUBI	A,'='
	BRZ	SYMDEF
	
	; IS IT A ':' TOKEN?
	SUBI	A,':'-'='
	BRZ	SYMLABL
	
	; PROCESS AS AN INSTRUCTION
	LOADI	B,ISR0_B
	LOADI	C,DOISR
	JUMP	INDIR
	
	; DO A LABEL
SYMLABL:LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,SYM0_B
	LOADI	C,DEFINE
	JUMP	INDIR
	
	; PUT COUNTER IN SYMBOL
	LOAD	A,[DFBANK]
	LOAD	B,[DFPNTR]
	LOAD	C,[COUNTER]
	STORE	[DBANK],A
	STOREF	[B+2],C
	LOADI	C,0
	STOREF	[B+1],C
	LOADI	A,0XFF
	STOREF	[B],A
	STORE	[DBANK],C
	JUMP	9F
	
	; ATTEMPT TO DEFINE THIS SYMBOL
SYMDEF:	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,SYM0_B
	LOADI	C,DEFINE
	JUMP	INDIR

	; ATTEMPT TO PARSE EXPRESSION
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	
	; DID THE EXPRESSION RETURN DEFINED?
	ADDI	A,0
	BRNZ	2F

	; STORE VALUE AND DEFINE
	STORE	[SPARK],D
	LOAD	A,[VALUE]
	LOAD	B,[VALUE+1]
	LOAD	C,[DFBANK]
	LOAD	D,[DFPNTR]
	STORE	[DBANK],C
	STOREF	[D+1],A
	STOREF	[D+2],B
	LOADI	A,0XFF
	STOREF	[D],A
	LOADI	A,0
	STORE	[DBANK],A
	LOAD	D,[SPARK]
	JUMP	8F

	; UN-DEFINE THE EXPRESSION
2:	LOADI	A,0
	LOAD	B,[DFBANK]
	LOAD	C,[DFPNTR]
	STORE	[DBANK],B
	STOREF	[C],A
	STORE	[DBANK],A
	
	; WE EXPECT A NEWLINE HERE
8:	LOAD	A,[TOKEN]
	SUBI	A,NEWLINE
	LOADI	A,E_UXTOK
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	BRNZ	INDIR
	
	; GO BACK TO ASMLINE
9:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	
BI	= BI+1
.TEXT
.BANK	BI
MAIN2_B	= BI

	; LINE STARTS WITH A NUMERIC
	; ATTEMPT TO DEFINE A LOCAL SYMBOL
ASMNUM:	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEN
	JUMP	INDIR
	
	; MAKE SURE IT IS LESS THAN 10
	LOAD	A,[VALUE]
	ADDI	A,0
	BRNZ	1F
	LOAD	A,[VALUE+1]
	LOADI	B,10
	CMP	A,B
	BRB	2F

	; ERROR!
1:	LOADI	A,E_LOBIG
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR

	; NOW LETS (MAYBE) DEFINE IT
2:	LOAD	B,[PASS]
	ADDI	B,0
	BRNZ	2F
	ADDI	A,'0'
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,SYM0_B
	LOADI	C,ADDLOC
	JUMP	INDIR
	
	; CONSUME ':' SYMBOL
2:	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	LOAD	A,[TOKEN]
	SUBI	A,':'
	BRZ	3F
	
	; ERROR!
	LOADI	A,E_UXTOK
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
	; INCREMENT LOCAL COUNTER
3:	LOAD	A,[NUMLOC+1]
	ADDI	A,1
	STORE	[NUMLOC+1],A
	BRNC	9F
	LOAD	A,[NUMLOC]
	ADDI	A,1
	STORE	[NUMLOC],A
	
	; GO BACK TO ASMLINE
9:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	
BI	= BI+1
.TEXT
.BANK	BI
MAIN3_B	= BI

	; LINE STARTS WITH A DIRECTIVE
	; WHICH ONE IS IT?
ASMDIR:	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	
	; CALL STRLOOK
	LOADI	A,S_ORG
	LOADI	C,@+3
	STOREF	[D],C
	JUMP	STRLOOK
	STORE	[TEMP],A
	
	; GET NEXT TOKEN RIGHT OFF THE BAT
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	
	; NOW WE SEE WHAT WE GOT
	LOAD	C,[TEMP]
	ADDI	C,0
	BRN	0F
	
	; HUH?
	LOADI	A,E_UDIR
	JUMP	9F

	; WE RECOGNIZE IT, JUMP TO IT
0:	LOADI	B,MAIN5_B
	JUMPR	C
	
	; STUB TABLE
DIRTEXT:LOADI	A,0
	LOADI	C,DIRSEG
	JUMP	INDIR
DIRDATA:LOADI	A,1
	LOADI	C,DIRSEG
	JUMP	INDIR
DIRBSS:LOADI	A,2
	LOADI	C,DIRSEG
	JUMP	INDIR
DIRORG:	LOADI	C,DIRORGA
	JUMP	INDIR
DIRBANK:LOADI	C,DIRBANA
	JUMP	INDIR

	
	; WE ARE DOING A DEFINE
	; GET THE DEFINE SIZE, CALL STRLOOK
DIRDEF:	LOAD	A,[TOKEN]
	SUBI	A,SYMBOL
	BRNZ	DIRUXTO
	LOADI	A,S_BYTE
	LOADI	C,@+3
	STOREF	[D],C
	JUMP	STRLOOK
	
	ADDI	A,0
	BRNZ	0F
	
	; HUH?
	LOADI	A,E_UDATA
	JUMP	9F
	
0:	STORE	[DEFSIZE],A
	JUMP	7F

	; WE ARE DOING A DEFINE LABEL
	; GET THE DEFINE SIZE, CALL STRLOOK
DIRDEFL:LOAD	A,[TOKEN]
	SUBI	A,SYMBOL
	BRNZ	DIRUXTO
	LOADI	A,S_BYTE
	LOADI	C,@+3
	STOREF	[D],C
	JUMP	STRLOOK
	
	ADDI	A,0
	BRNZ	0F
	
	; HUH?
	LOADI	A,E_UDATA
	JUMP	9F
	
0:	STORE	[DEFSIZE],A

	; NOW WE DEFINE A LABEL WITH THE CURRENT COUNTER VALUE
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	
	; GOTTA BE A SYMBOL
	LOAD	A,[TOKEN]
	SUBI	A,SYMBOL
	BRZ	1F
	
	; ERROR! UNEXPECTED TOKEN
DIRUXTO:LOADI	A,E_UXTOK
	JUMP	9F
	
	; DEFINE SYMBOL NOW
1:	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,SYM0_B
	LOADI	C,DEFINE
	JUMP	INDIR
	
	; PUT COUNTER IN SYMBOL
	LOAD	A,[DFBANK]
	LOAD	B,[DFPNTR]
	LOAD	C,[COUNTER]
	STORE	[DBANK],A
	STOREF	[B+2],C
	LOADI	C,0
	STOREF	[B+1],C
	LOADI	A,0XFF
	STOREF	[B],A
	STORE	[DBANK],C
	
	; NOW WE CAN GO AND DO THE DEFINITION
7:	LOADI	B,MAIN4_B
	LOADI	C,DIRDDEF
	JUMP	INDIR
	

	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
	; LOOKUP A STRING IN THE STR_B
	; A = FIRST STRING TO CHECK AGAINST
	; RETURNS RESULT IN A
STRLOOK:STORE	[SPARK],D
STRNEXT:LOADI	B,TBUF
0:	LOADF	C,[B]
	LOADI	D,STR_B
	STORE	[DBANK],D
	LOADF	D,[A]
	CMP	C,D
	BRNZ	2F
	ADDI	C,0
	BRZ	1F
	LOADI	D,0
	STORE	[DBANK],D
	ADDI	A,1
	ADDI	B,1
	JUMP	0B
	
	; WE GOT A MATCH
1:	LOADF	A,[A+1]
	JUMP	5F
	
	; DOES NOT MATCH
2:	LOADF	D,[A]
	ADDI	D,0
	BRZ	3F
	ADDI	A,1
	JUMP	2B
3:	ADDI	A,2
	LOADF	C,[A]
	STORE	[DBANK],D
	ADDI	C,0
	BRNZ	STRNEXT
	
	; OUT OF OPTIONS
	LOADI	A,0

	; EXIT
5:	LOADI	D,0
	STORE	[DBANK],D
	LOAD	D,[SPARK]
	JUMP	IRET
	
BI	= BI+1
.TEXT
.BANK	BI
MAIN4_B	= BI

	; ACTUALLY DO THE DEFINITION OPERATION HERE
DIRDDEF:LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	
	; IF ITS A NEW LINE, WE ARE DONE
0:	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	
	; SPECIAL CASE, IF WE JUST GOT A DQUOTE WE WILL JUST START OUTPUTTING ASCII CHARACTERS
	SUBI	A,DQUOTE-NEWLINE
	BRNZ	6F
	
1:	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	
	; JUST EMIT TOKENS STILL WE GET ANOTHER DQUOTE
	LOAD	A,[TOKEN]
	SUBI	A,DQUOTE
	BRZ	3F
	SUBI	A,NEWLINE-DQUOTE
	BRZ	2F
	ADDI	A,NEWLINE
	BRZ	2F
	
	; PLACE IN [VALUE]
	LOADI	B,0
	STORE	[VALUE],B
	STORE	[VALUE+1],A
	
	; AND EMIT
	LOADI	C,1B
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR

	; STRING IS BAD!
2:	LOADI	A,E_UCSTR
	JUMP	9F

	; GRAB THE TOKEN AFTER THE DOUBLE QUOTES
3:	LOADI	C,7F
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; HMM, MUST BE AN EXPRESSION
	; LETS PARSE IT
6:	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	
	; WHAT PASS ARE WE ON?
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	
	; WE ARE ON PASS 2, MAKE SURE IT ISN'T UNDEFINED
	ADDI	A,0
	LOADI	A,E_UDEFX
	BRN	9F

	; IF WE ARE IN THE DATA SEGMENT AND DEFSIZE IS 2, EMIT VALUE IN TWO PARTS
1:	LOAD	A,[SEGMENT]
	ADDI	A,0
	BRZ	2F
	LOAD	A,[DEFSIZE]
	SUBI	A,1
	BRZ	2F
	
	; EMIT IN TWO PARTS
	LOAD	A,[VALUE+1]
	STORE	[TEMP],A
	LOAD	A,[VALUE]
	STORE	[VALUE+1],A
	LOADI	A,0
	STORE	[VALUE],A
	
	; EMIT FIRST VALUE
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR
	
	; EMIT SECOND VALUE
	LOAD	A,[TEMP]
	STORE	[VALUE+1],A
	
	; EMIT VALUE
2:	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR

	; CHECK IF ITS A COMMA
7:	LOAD	A,[TOKEN]
	SUBI	A,','
	BRNZ	DIRNEWL
	
	; CONSUME TOKENS TILL IT'S NO LONGER A NEWLINE
1:	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR
	LOAD	A,[TOKEN]
	SUBI	A,NEWLINE
	BRZ	1B
	JUMP	0B

	; THIS BETTER BE A NEWLINE
DIRNEWL:LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	; NOPE 
	LOADI	A,E_UXTOK
	JUMP	9F


	; GO BACK TO ASMLINE
8:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	

	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR

BI	= BI+1
.TEXT
.BANK	BI
MAIN5_B	= BI

	; SET THE COUNTER ORIGIN MANUALLY
DIRORGA:LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	ADDI	A,0
	LOADI	A,E_UDEFX
	BRNZ	9F
	
	; SET [COUNTER] TO [VALUE]
	LOAD	A,[VALUE+1]
	STORE	[COUNTER],A
	LOAD	A,[VALUE]
	ADDI	A,0
	LOADI	A,E_VBIG
	BRNZ	9F
	
	; MAKE SURE IT ENDS WITH A NEWLINE
	JUMP	7F
	
	; SET THE BANK ORIGIN MANUALLY
DIRBANA:LOAD	C,[SELBANK]
	STORE	[DEFSIZE],C
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	ADDI	A,0
	LOADI	A,E_UDEFX
	BRNZ	9F
	
	; SET [SELBANK] TO [VALUE]
	LOAD	A,[VALUE+1]
	STORE	[SELBANK],A
	LOAD	A,[VALUE]
	ADDI	A,0
	LOADI	A,E_VBIG
	BRNZ	9F
	
	; RESET THE SEGMENT
	LOAD	A,[DEFSIZE]
	STORE	[TEMP],A
	LOAD	A,[SEGMENT]
	LOADI	C,7F
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,SETSEG
	JUMP	INDIR

	; SET THE SEGMENT
DIRSEG:	LOAD	C,[SELBANK]
	STORE	[TEMP],C
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,7F
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,SETSEG
	JUMP	INDIR
	
	; THIS BETTER BE A NEWLINE
7:	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	; NOPE 
	LOADI	A,E_UXTOK
	JUMP	9F

	; GO BACK TO ASMLINE
8:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR

	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR