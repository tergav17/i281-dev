; AS5.S
; ASSEMBLY OUTPUT GENERATOR
; GAVIN TERSTEEG, 2024
; SDMAY24-14

BI	= BI+1
.TEXT
.BANK	BI
EMIT0_B	= BI

	; INITALIZE THE EMISSION SECTION
	; CREATE THE OUTPUT FILE, AND RESET ALL BANK STATE INFORMATION
EMINIT:	LOADI	A,0
	STORE	[FNEXT],A
	
	; CLEAR ALLOCATION TABLE
	LOADI	B,0
	LOADI	A,ALLOC_B
	LOADI	C,@+2
	JUMP	9F
	LOADI	A,ALLOC_B+1
	LOADI	C,@+2
	JUMP	9F
	
	; CREATE 'AOUT' FILE
	SUBI	D,2
	LOADI	B,STR_B
	STORE	[ARG_BNK],B
	LOADI	A,AOUT
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,S_CREAT
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	BRZ	1F
	
	; ERROR!
	LOADI	A,AOUTERR
	LOADI	B,S_PUTS
	LOADI	C,@+2
	JUMP	SYSCALL
	LOADI	B,S_EXIT
	JUMP	SYSCALL
	
	; RESET DIRTY
1:	LOADI	A,0
	STORE	[DIRTY],A

	ADDI	D,2
	JUMP	IRET

	; RESET COUNTERS FOR THE NEXT PASS
	; ALSO OPENS UP BANK 1
EMPASS:	LOADI	B,0
	LOADI	A,DCNT_B
	LOADI	C,@+2
	JUMP	9F
	LOADI	A,DCNT_B+1
	LOADI	C,@+2
	JUMP	9F

	; DO WE START IN THE LOWER SECTION?
	LOAD	A,[LFLAG]
	ADDI	A,0
	BRNZ	1F
	LOADI	B,0X80
	
	; RESET CODE MEMORY COUNTERS
1:	LOADI	A,CCNT_B
	LOADI	C,@+2
	JUMP	9F
	LOADI	A,CCNT_B+1
	LOADI	C,@+2
	JUMP	9F
	
	; ALSO SET THE COUNTER
	STORE	[COUNTER],B
	
	; SET DEFAULT SEGMENT TO TEXT
	LOADI	A,0
	STORE	[SEGMENT],A
	
	; FALL THROUGH TO SETBANK
	LOADI	A,1
	STORE	[SELBANK],A
	
	; UPDATES CURBANK TO BE EQUAL TO SELBANK
	; [SELBANK] = BANK TO EMIT INTO
SETBANK:LOADI	B,EMIT1_B
	LOADI	C,SETBANA
	JUMP	INDIR

	; SERVICE FUNCTION TO FILL A BANK
	; A = BANK TO CLEAR
	; B = FILL BYTE
	; C = RETURN ADDRESS
9:	STORE	[DBANK],A
	LOADI	A,0
0:	STOREF	[A],B
	ADDI	A,1
	BRNN	0B
	LOADI	A,0
	STORE	[DBANK],A
	JUMPR	C
	
	; EMITS A BYTE OR WORD INTO THE OUTPUT BINARY
	; [VALUE] = VALUE TO EMIT
	; [COUNTER] = LOCATION IN OUTPUT BINARY TO EMIT
	; [SEGMENT] = SEGMENT TO EMIT INTO
EMIT:	LOADI	B,EMIT3_B
	LOADI	C,EMITA
	JUMP	INDIR
	
	; SETS THE CURRENT SEGMENT
	; A = SEGMENT TO SET
	; [TEMP] = PREVIOUS BANK
SETSEG:	LOADI	B,EMIT4_B
	LOADI	C,SETSEGA
	JUMP	INDIR
	
BI	= BI+1
.TEXT
.BANK	BI
EMIT1_B	= BI

	; SHADOW OF SETBANK
SETBANA:SUBI	D,2

	; ITS POSSIBLE WE MAY BE WRITING TO THE OUTPUT FILE, LETS OPEN IT
	LOADI	B,STR_B
	STORE	[ARG_BNK],B
	LOADI	A,AOUT
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,S_OPEN
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	LOADI	A,E_COPEN
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	BRNZ	INDIR
	
	; FIRST THING'S FIRST, DO WE NEED TO SAVE THE CURRENT BANK
	LOAD	A,[DIRTY]
	ADDI	A,0
	LOADI	B,EMIT2_B
	LOADI	C,SETBANB
	BRZ	INDIR
	
	; THIS BANK IS DIRTY, LETS WRITE IT TO DISK
	; HAS IT BEEN ALLOCATED YET?
	LOAD	A,[CURBANK]
	LOADI	B,ALLOC_B
	SHIFTL	A
	BRNC	3F
	ADDI	B,1
3:	SHIFTR	A
	STORE	[DBANK],B
	LOADF	C,[A]
	ADDI	C,0
	BRZ	4F
	
	; BANK IS ALLOCATED, GET THE BLOCK #
	SUBI	B,ALLOC_B-BTAB_B
	STORE	[DBANK],B
	LOADF	C,[A]
	LOADI	A,0
	STORE	[DBANK],A
	JUMP	5F

	; BANK IS NOT ALLOCATED, DO SO
4:	LOADI	C,0XFF
	STOREF	[A],C
	LOADI	C,0
	STORE	[DBANK],C
	
	; GET NEXT FREE BLOCK
	LOAD	C,[FNEXT]
	ADDI	C,1
	STORE	[FNEXT],C
	SUBI	C,1
	
	; PUT IN BLOCK TABLE
	SUBI	B,ALLOC_B-BTAB_B
	STORE	[DBANK],B
	STOREF	[A],C
	LOADI	A,0
	STORE	[DBANK],A
	
	; WRITE THE BLOCK
5:	MOV	A,C
	LOADI	B,WORK_B
	STORE	[ARG_BNK],B
	LOADI	B,S_WRITE
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	LOADI	A,E_FIO
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	BRNZ	INDIR
	
	; NOW WE CAN READ THE NEXT BANK IN
	LOADI	B,EMIT2_B
	LOADI	C,SETBANB
	JUMP	INDIR
	
BI	= BI+1
.TEXT
.BANK	BI
EMIT2_B	= BI

	; CONTINUATION OF SETBANK
	; LETS NOW READ THE NEXT BANK IN  (IF IT EXISTS)
SETBANB:LOADI	C,BI
	STOREF	[D+1],C
	
	; HAS IT BEEN ALLOCATED YET?
	LOAD	A,[SELBANK]
	LOADI	B,ALLOC_B
	SHIFTL	A
	BRNC	0F
	ADDI	B,1
0:	SHIFTR	A
	STORE	[DBANK],B
	LOADF	C,[A]
	ADDI	C,0
	BRZ	1F
	
	; YEP, WE CAN JUST READ IT IN
	SUBI	B,ALLOC_B-BTAB_B
	STORE	[DBANK],B
	LOADF	C,[A]
	LOADI	A,0
	STORE	[DBANK],A
	
	; DO FILE READ OPERATION
	MOV	A,C
	LOADI	B,WORK_B
	STORE	[ARG_BNK],B
	LOADI	B,S_READ
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	LOADI	A,E_FIO
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	BRNZ	INDIR
	JUMP	8F

	; UH OH, THIS IS A NEW BANK
	; LETS INIT WORK_B
1:	LOADI	B,0
	STORE	[DBANK],B
	LOAD	A,[SELBANK]
	LOADI	B,WORK_B
	STORE	[DBANK],B
	STORE	[2],A
	LOADI	A,0X02
	STORE	[0],A
	LOADI	A,0X81
	STORE	[1],A
	LOADI	A,0X03
	LOADI	B,0XFF
2:	STOREF	[A],B
	ADDI	A,1
	BRNN	2B
	
	; CLEAR READ OF WORK_B
	LOADI	B,0
	LOADI	A,WORK_B+1
	LOADI	C,@+2
	JUMP	9F
	LOADI	A,WORK_B+2
	LOADI	C,@+2
	JUMP	9F
	LOADI	A,WORK_B+3
	LOADI	C,@+2
	JUMP	9F
	
	; ALL DONE, LETS RE-OPEN THE INPUT FILE
	; MAYBE?
8:	LOAD	A,[SRCINDX]
	LOAD	B,[ARGC]
	CMP	A,B
	BRAE	8F
	LOAD	B,[CMDL_B]
	STORE	[ARG_BNK],B
	LOADF	A,[A+ARGV]	
	LOADI	B,S_OPEN
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	LOADI	A,E_COPEN
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	BRNZ	INDIR
	
	; SET CURBANK TO SELBANK
8:	LOAD	A,[SELBANK]
	STORE	[CURBANK],A
	
	; RESET DIRTY
	LOADI	A,0
	STORE	[DIRTY],A

	ADDI	D,2
	JUMP	IRET
	
	; SERVICE FUNCTION TO FILL A BANK
	; A = BANK TO CLEAR
	; B = FILL BYTE
	; C = RETURN ADDRESS
9:	STORE	[DBANK],A
	LOADI	A,0
0:	STOREF	[A],B
	ADDI	A,1
	BRNN	0B
	LOADI	A,0
	STORE	[DBANK],A
	JUMPR	C

BI	= BI+1
.TEXT
.BANK	BI
EMIT3_B	= BI

	; SHADOW OF EMIT
EMITA:	SUBI	D,2

	; DON'T DO ANYTHING IF WE ARE ON THE FIRST PASS
	LOAD	A,[PASS]
	ADDI	A,0
	BRZ	9F

	; DOES SELBANK MATCH CURBANK?
	; IF NOT, LETS FIX THAT
	LOAD	A,[CURBANK]
	LOAD	B,[SELBANK]
	CMP	A,B
	BRZ	0F
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EMIT0_B
	LOADI	C,SETBANK
	JUMP	INDIR
	
	; WHAT SEGMENT ARE WE IN?
0:	LOAD	A,[SEGMENT]
	ADDI	A,0
	BRNZ	5F
	
	; TEXT SEGMENT!
	; LETS MAKE SURE THE COUNTER ISN'T OUT OF BOUNDS
	LOAD	A,[COUNTER]
	LOAD	B,[LFLAG]
	ADDI	B,0
	BRNZ	1F
	
	; CORRECT ADDRESS
	SUBI	A,0X80

	; MAKE SURE IT ISN'T NEGATIVE
1:	ADDI	A,0
	BRP	3F
2:	LOADI	A,E_TFULL
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR

	; PLACE [VALUE] INTO BUFFER
3:	LOADI	B,WORK_B+2
	SHIFTL	A
	BRNC	4F
	ADDI	B,1
4:	LOAD	C,[VALUE]
	STORE	[DBANK],B
	STOREF	[A],C
	LOADI	C,0
	STORE	[DBANK],C
	LOAD	C,[VALUE+1]
	STORE	[DBANK],B
	STOREF	[A+1],C
	LOADI	C,0
	STORE	[DBANK],C
	JUMP	8F

	; DATA SEGMENT! (OR BSS)
	; LETS MAKE SURE THE COUNTER ISN'T OUT OF BOUNDS
5:	LOAD	A,[COUNTER]
	ADDI	A,0
	BRP	6F
	
	; ERROR!
	LOADI	A,E_DFULL
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
	; ARE WE IN BSS SPACE?
6:	LOAD	B,[SEGMENT]
	LOAD	C,[VALUE+1]
	SUBI	B,1
	BRZ	7F
	
	; BSS SEGMENT!
	ADDI	C,0
	BRZ	9F
	LOADI	A,E_BSS
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR

	; DATA SEGMENT!
7:	LOADI	B,WORK_B+1
	STORE	[DBANK],B
	STOREF	[A],C
	LOADI	C,0
	STORE	[DBANK],C
	
	; SET DIRTY
8:	LOADI	A,0XFF
	STORE	[DIRTY],A

	; INCREMENT COUNTER
9:	LOAD	A,[COUNTER]
	ADDI	A,1
	STORE	[COUNTER],A

	; DONE
	ADDI	D,2
	JUMP	IRET
	
BI	= BI+1
.TEXT
.BANK	BI
EMIT4_B	= BI

	; SHADOW OF SETSEG
SETSEGA:LOAD	B,[SEGMENT]
	STORE	[SEGMENT],A
	
	; WAS THE OLD SEGMENT TEXT OR DATA (BSS)
	ADDI	B,0
	BRZ	0F
	LOADI	B,DCNT_B
	JUMP	1F
0:	LOADI	B,CCNT_B

	; WHAT BANK DO WE PUT IT IN?
1:	LOAD	A,[TEMP]
	SHIFTL	A
	BRNC	2F
	ADDI	B,1
2:	SHIFTR	A
	LOAD	C,[COUNTER]
	STORE	[DBANK],B
	STOREF	[A],C
	LOADI	A,0
	STORE	[DBANK],A
	
	; IS THE NEW SEGMENT TEXT OR DATA (BSS)
	LOAD	B,[SEGMENT]
	ADDI	B,0
	BRZ	0F
	LOADI	B,DCNT_B
	JUMP	1F
0:	LOADI	B,CCNT_B

	; WHAT BANK DO WE GET IT FROM?
1:	LOAD	A,[SELBANK]
	SHIFTL	A
	BRNC	2F
	ADDI	B,1
2:	SHIFTR	A
	STORE	[DBANK],B
	LOADF	C,[A]
	LOADI	A,0
	STORE	[DBANK],A
	STORE	[COUNTER],C
	
	; DONE
	JUMP	IRET

	; BLOCK ADDRESS TABLE
	; TURNS A LOGIC SAV BLOCK INTO A PHYSICAL FILE BLOCK
.BANK	BD
.BSS
BTAB_B	= BD


BD	= BD+2

	; BLOCK ALLOCATION TABLE
	; MARKS IF A LOGICAL SAV BLOCK HAS BEEN ALLOCATED YET
.BANK	BD
.BSS
ALLOC_B	= BD


BD	= BD+2

	; DATA BANK COUNTERS
	; STORES DATA COUNTERS FOR EACH BANK
.BANK	BD
.BSS
DCNT_B	= BD


BD	= BD+2

	; CODE BANK COUNTERS
	; STORES CODE COUNTERS FOR EACH BANK
.BANK	BD
.BSS
CCNT_B	= BD


BD	= BD+2

	; WORK BANK FOR STORAGE .SAV RECORDS
	; WORK_B + 0 = RECORD HEADER
	; WORK_B + 1 = DATA SEGMENT
	; WORK_B + 2 = ISR SEGMENT 128-191
	; WORK_B + 3 = ISR SEGMENT 192-255
.BANK	BD
.BSS
WORK_B	= BD


BD	= BD+4