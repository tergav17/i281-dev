; ED3.S
; SIMPLE TEXT EDITOR
; MEMORY AND FILE OPERATIONS


.TEXT
.BANK	BI
MEM0_B	= BI

	; MEMORY INIT
	; DIVIDE THE HEAP INTO BLOCKS OF 32 BYTES, AND ADD IT
	; TO THE FREE TABLE
	; ALSO RESET THE LINE TABLE
	; USES: A, B, C
MINIT:	LOADI	C,HEAP
	LOAD	B,[MAX_DB]
	
	; SET THE START OF THE FREE BLOCK LIST
	; AND RESET LINE TABLE
	LOADI	A,0
	STORE	[FREETAB],C
	STORE	[FREETAB+1],A
	STORE	[LINETAB],A
	
	; MOVE TO BANK
0:	STORE	[DBANK],C
	LOADI	A,32
	
	; WRITE FIRST 3 HEADERS
1:	STOREF	[A+1-32],A
	STOREF	[A+0-32],C
	ADDI	A,32
	BRNN	1B
	
	; WRITE 4TH HEADER
2:	LOADI	A,0
	STORE	[32*3+1],A
	ADDI	C,1
	CMP	C,B
	BRA	3F
	STORE	[32*3],C
	JUMP	0B
	
	; STORE BANK ZERO TO INDICATE END OF LIST
3:	STORE	[32*3],A
	STORE	[DBANK],A
	
	; CALCULATE NUMBER OF FREE BLOCKS
	LOADI	C,HEAP-1
	SUB	B,C
	SHIFTL	B
	BRNC	4F
	ADDI	A,1
4:	SHIFTL	B
	BRNC	5F
	SHIFTL	A
	ADDI	A,1

5:	STORE	[NUMFREE],A
	STORE	[NUMFREE+1],B
	
	JUMP	IRET
	
	
	; ALLOCATE A BLOCK OF MEMORY
	; BLOCK WILL BE LINKED ONTO THE CURRENT BLOCK IN [CBLOCK]
	; THEN IT WILL BE RETURN IN [CBLOCK]
	; RETURNS A = 0XFF OUT OF BLOCKS, A = 0X00 OTHERWISE
	; USES: A, B, C
MALLOC:	STORE	[SPARK],D
	LOAD	B,[FREETAB]
	
	; MAKE SURE THE NEXT BLOCK ISN'T NULL
	ADDI	B,0
	LOADI	A,0XFF
	BRZ	IRET
	
	; STORE THE BLOCK ADDRESS IN LBLOCK
	LOAD	C,[FREETAB+1]
	STORE	[LBLOCK],B
	STORE	[LBLOCK+1],C
	
	; MOVE THE NEXT BLOCK INTO FREETAB POINTER
	STORE	[DBANK],B
	LOADF	A,[C]
	LOADF	B,[C+1]
	LOADI	D,0
	STOREF	[C],D
	STOREF	[C+1],D
	STORE	[DBANK],D
	STORE	[FREETAB],A
	STORE	[FREETAB+1],B
	
	; RETURN TO USER BANK
	LOADI	A,0
	STORE	[DBANK],A
	
	; SET THE MEMORY BLOCK POINTER
	LOAD	A,[LBLOCK+1]
	ADDI	A,3
	STORE	[MB_PNTR],A
	ADDI	A,32-3
	STORE	[MB_END],A
	LOADI	A,0
	STORE	[LINES],A
	
	; DECREMENT NUMFREE
	LOAD	A,[NUMFREE+1]
	SUBI	A,1
	STORE	[NUMFREE+1],A
	BRC	0F
	LOAD	A,[NUMFREE]
	SUBI	A,1
	STORE	[NUMFREE],A
	
	; RESTORE STACK AND LINK
0:	LOAD	D,[SPARK]
	
	
	; LINK THE BLOCK IN LBLOCK ONTO CBLOCK
	; THE NEXT BLOCK OF CBLOCK WILL BECOME
	; THE NEXT BLOCK OF LBLOCK
	; AFTER THAT, CBLOCK WILL BECOME LBLOCK
	; RETURNS A = 0X00
	; USES: A, B, C
LINK:	STORE	[SPARK],D
	
	; GET ADDRESS OF CBLOCK AND LBLOCK
	LOAD	A,[CBLOCK]
	LOAD	B,[CBLOCK+1]
	LOAD	C,[LBLOCK]
	LOAD	D,[LBLOCK+1]
	
	; GRAB THE NEXT ADDRESS OF CBLOCK AND SET IT IN LBLOCK
	STORE	[DBANK],A
	LOADF	A,[B]
	LOADF	B,[B+1]
	STORE	[DBANK],C
	STOREF	[D],A
	STOREF	[D+1],B
	LOADI	A,0
	STORE	[DBANK],A
	
	; RE-GRAB ADDRESS OF CBLOCK
	LOAD	A,[CBLOCK]
	LOAD	B,[CBLOCK+1]
	
	; SET CBLOCK NEXT TO LBLOCK
	STORE	[DBANK],A
	STOREF	[B],C
	STOREF	[B+1],D
	
	; SET CBLOCK TO LBLOCK
	LOADI	A,0
	STORE	[DBANK],A
	LOAD	A,[LBLOCK]
	LOAD	B,[LBLOCK+1]
	STORE	[CBLOCK],A
	STORE	[CBLOCK+1],B
	
	; DONE, RESTORE STACK AND RETURN
	LOADI	A,0
	LOAD	D,[SPARK]
	JUMP	IRET
	
	; PLACES THE BLOCK IN [CBLOCK] ONTO THE FREE
	; TABLE
	; USES: A, B, C
FREE:	STORE	[SPARK],D

	; GRAB ADDRESSES OF THE FREETAB AND CBLOCK
	LOAD	A,[CBLOCK]
	LOAD	B,[CBLOCK+1]
	LOAD	C,[FREETAB]
	LOAD	D,[FREETAB+1]
	
	; LINK REST OF FREETAB AFTER CBLOCK
	STORE	[DBANK],A
	STOREF	[B],C
	STOREF	[B+1],D
	
	; SET CBLOCK AS BEGINNING OF FREE TABLE
	LOADI	C,0
	STORE	[DBANK],C
	STORE	[FREETAB],A
	STORE	[FREETAB+1],B
	
	; INCREMENT NUMFREE
	LOAD	A,[NUMFREE+1]
	ADDI	A,1
	STORE	[NUMFREE+1],A
	BRNC	0F
	LOAD	A,[NUMFREE]
	ADDI	A,1
	STORE	[NUMFREE],A
	
	; RESTORE STACK AND RETURN
0:	LOAD	D,[SPARK]
	JUMP	IRET
	
	; GETS THE NEXT BLOCK AFTER CBLOCK
	; RETURNS A=0X00 IF NEXT, 0XFF OTHERWISE
	; USES: A, B, C
;NEXT:	LOAD	B,[CBLOCK]
;	LOAD	C,[CBLOCK+1]
;	LOADI	A,0XFF
;	ADDI	B,0
;	BRZ	IRET
;	STORE	[DBANK],B
;	LOADF	B,[C]
;	LOADF	C,[C+1]
;	LOADI	A,0
;	STORE	[DBANK],A
;	LOADI	A,0XFF
;	ADDI	B,0
;	BRZ	IRET
;	STORE	[CBLOCK],B
;	STORE	[CBLOCK+1],C
;	LOADI	A,0
;	JUMP	IRET
	
	
	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
.TEXT
.BANK	BI
FIO0_B	= BI
	
	; WRITES THE BUFFER BACK INTO A FILE
	; [FNAME] = FILE TO OPEN
	; RETURNS A = 0XFF IF ERROR, A = 0X00 RETURN OTHERWISE
	; USES: A, B, C
FWRITE: SUBI	D,2

	; SET FIRST FLAG
	LOADI	C,0XFF
	STORE	[FIRST],C

	; INDIRECT TO FWRITEA
	LOADI	B,FIO2_B
	LOADI	C,FWRITEA
	JUMP	INDIR
	
	; READS A FILE INTO THE BUFFER
	; [FNAME] = FILE TO OPEN
	; RETURNS A = 0XFF IF ERROR, A = 0X00 RETURN OTHERWISE
	; USES: A, B, C
FREAD:	SUBI	D,2

	; SET FIRST FLAG
	LOADI	C,0X0A
	STORE	[FIRST],C
	
	; SET OPEN TARGET
	LOADI	A,0
	STORE	[ARG_BNK],A
	LOADI	A,FNAME
	
	; ATTEMPT TO OPEN FILE
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,S_OPEN
	LOADI	C,@+2
	JUMP	SYSCALL
	
	; CHECK RESULT OF OPERATION
	ADDI	A,0
	BRNZ	9F
	
	; RE-INITALIZE MEMORY
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,MEM0_B
	LOADI	C,MINIT
	JUMP	INDIR
	
	; MALLOC FIRST BLOCK
	LOADI	A,0
	STORE	[CBLOCK],A
	STORE	[LINETAB],A
	STORE	[LINETAB+1],A
	LOADI	A,LINETAB
	STORE	[CBLOCK+1],A
	
	; SET RETURN TO FREADA
	LOADI	C,FREADA
	STOREF	[D],C
	LOADI	C,FIO1_B
	STOREF	[D+1],C
	LOADI	B,MEM0_B
	LOADI	C,MALLOC
	JUMP	INDIR

	; RESTORE STACK AND RETURN
9:	ADDI	D,2
	JUMP	IRET


	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
.TEXT
.BANK	BI
FIO1_B	= BI

	; CONTINUED FREAD CODE
	; RESET BLOCK READ IN STATE
FREADA:	LOADI	A,BUF_B
	STORE	[ARG_BNK],A
	LOADI	A,0
	
	; READ THE BLOCK
	LOADI	C,BI
	STOREF	[D+1],C
0:	STORE	[BLOCK],A
	LOADI	B,S_READ
	LOADI	C,@+2
	JUMP	SYSCALL

	; DID IT WORK?
	ADDI	A,0
	BRNZ	0F
	
	; RESET THE BLOCK READ STATE
	LOADI	A,BUF_B
	STORE	[BANK],A
	LOADI	B,0
	
	; CHECK FIRST FLAG
	LOAD	C,[FIRST]
	STORE	[FIRST],B
	SUBI	B,1
	ADDI	C,0
	BRNZ	2F
	
	; SET POINTER TO ZERO
	ADDI	B,1
	
	; READ CHARACTER FROM BLOCK
1:	STORE	[BANK],A
	STORE	[DBANK],A
	LOADF	C,[B]
	LOADI	A,0
	STORE	[DBANK],A
	
	; PROCESS CHARACTER
	; C = CHARACTER
2:	STORE	[POINTER],B
	LOADI	B,0X20
	CMP	C,B
	BRB	3F
	LOADI	B,0X80
	CMP	C,B
	BRB	6F
	JUMP	8F
	
	; CONTROL CHARACTERS
3:	LOADI	B,0X09	; TAB CHARACTER
	CMP	C,B
	BRZ	6F
	ADDI	C,0	; NULL CHARACTER
	BRZ	0F
	LOADI	B,0X0A	; NEW LINE CHARACTER
	CMP	C,B
	BRNZ	8F
	LOADI	C,0
	
	; STORE VALUE IN MEMORY BLOCK
6:	LOAD	A,[MB_PNTR]
	LOAD	B,[MB_END]
	CMP	A,B
	LOAD	B,[CBLOCK]
	BRZ	7F
	STORE	[DBANK],B
	STOREF	[A],C
	LOADI	B,0
	STORE	[DBANK],B
	ADDI	C,0
	BRNZ	FREADNX		; NOT A NEXT LINE
	LOAD	B,[LINES]	; INCREMENT LINE
	ADDI	B,1
	STORE	[LINES],B
FREADNX:ADDI	A,1
	STORE	[MB_PNTR],A
	JUMP	8F

	; FINISH BLOCK
7:	STORE	[CHAR],C
	LOAD	A,[CBLOCK+1]
	LOAD	C,[LINES]
	STORE	[DBANK],B
	STOREF	[A+2],C
	LOADI	B,0
	STORE	[DBANK],B
	STORE	[LINES],B

	; ALLOC ANOTHER BLOCK
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,MEM0_B
	LOADI	C,MALLOC
	JUMP	INDIR
	
	; RESTORE CHARACTER
	LOAD	C,[CHAR]
	JUMP	6B
	
	; INCREMENT BLOCK POINTER
8:	LOAD	A,[BANK]
	LOAD	B,[POINTER]
	ADDI	B,1
	BRNN	1B
	LOADI	B,0
	ADDI	A,1
	LOADI	C,BUF_B+4 
	CMP	A,C
	BRNZ	1B
	LOAD	A,[BLOCK]
	ADDI	A,1
	BRNZ	0B
	
	; TERMINATE THE RECORD
0:	STORE	[SPARK],D
	LOAD	A,[MB_PNTR]
	LOAD	B,[MB_END]
	LOAD	C,[LINES]
	LOAD	D,[CBLOCK]
	STORE	[DBANK],D
	CMP	A,B
	BRZ	1F
	LOADI	D,0XFF
	STOREF	[A],D
1:	STOREF	[B+2-32],C
	LOADI	D,0
	STORE	[DBANK],D
	LOAD	D,[SPARK]
	
	; RESTORE STACK AND RETURN
	LOADI	A,0
9:	LOADI	B,0
	STORE	[DBANK],B
	ADDI	D,2
	JUMP	IRET

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
.TEXT
.BANK	BI
FIO2_B	= BI

	; SHADOW OF FWRITE
	; START BY CLOSING A FILE IF IT'S OPEN
FWRITEA:LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,S_CLOSE
	LOADI	C,@+2
	JUMP	SYSCALL
	
	; SAVE STACK
	STORE	[SPARK],D
	
	; SET CREAT TARGET
	LOADI	A,0
	STORE	[ARG_BNK],A
	LOADI	A,FNAME
	
	; ATTEMPT TO CREAT FILE
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,S_CREAT
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	BRNZ	9F
	
	; SET ARG BANK
	LOADI	A,BUF_B
	STORE	[ARG_BNK],A
	
	; RESET BANK / BLOCK / POINTER INFORMATION
	LOADI	A,BUF_B
	STORE	[BANK],A
	LOADI	A,0
	STORE	[BLOCK],A
	STORE	[POINTER],A
	
	; SET AT START OF BUFFER
	LOAD	C,[LINETAB]
	LOAD	D,[LINETAB+1]
	LOADI	B,4
	ADD	B,D
	ADDI	D,32
	STORE	[MB_END],D
	
	; READ A VALUE FROM THE LINE BUFFER
0:	STORE	[MB_PNTR],B
	STORE	[CBLOCK],C
	STORE	[MB_END],D
	LOADI	A,0
	ADDI	C,0
	BRZ	1F	; END OF LINE BUFFER
	STORE	[DBANK],C
	LOADF	A,[B]
	LOADI	B,0
	STORE	[DBANK],B
	ADDI	A,0
	
	; IF THE CHARACTER IS ZERO, DO CR/LF
	LOADI	B,0X0D
	BRZ	2F
	
	; IF THE CHARATER IS NEGATIVE, MOVE ON TO THE NEXT BLOCK
	BRN	4F
	
	; OTHERWISE, JUST PUT IT IN VERBATIM
1:	MOV	B,A
	
	; WRITE A CHARACTER TO THE OUTPUT BUFFER
2:	STORE	[CHAR],B
	LOAD	C,[BANK]
	LOAD	D,[POINTER]
	ADDI	D,0
	BRNN	3F
	
	; POINTER TOO BIG, RESET IT AND INCREMENT D
	ADDI	C,1
	LOADI	D,BUF_B+4
	CMP	C,D
	LOADI	D,0
	BRNZ	3F
	
	; BANK TOO BIG, WRITE THE BANK AND RESET
	; TODO: WRITE BANK HERE
	LOAD	A,[BLOCK]
	LOAD	D,[SPARK]
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	B,S_WRITE
	LOADI	C,@+2
	JUMP	SYSCALL
	ADDI	A,0
	BRNZ	9F
	
	; INCREMENT BLOCK
	LOAD	A,[BLOCK]
	ADDI	A,1
	STORE	[BLOCK],A
	LOADI	A,0XFF
	BRZ	8F

	; RESET STATE
	LOADI	C,BUF_B
	LOADI	D,0
	
	; IF THE CHAR IS 0, THEN WE ARE DONE
	LOAD	B,[CHAR]
	ADDI	B,0
	BRZ	8F

	; ADDRESS IS GOOD, WRITE IT
3:	STORE	[DBANK],C
	STOREF	[D],B
	LOADI	A,0
	STORE	[DBANK],A
	
	; INCREMENT POINTER AND STORE
	ADDI	D,1
	STORE	[BANK],C
	STORE	[POINTER],D
	
	; REPEAT IF ZERO
	ADDI	B,0
	BRZ	2B
	
	; INSERT A 0X0A IF WE JUST DID A 0X0D
	SUBI	B,0X0D
	LOADI	B,0X0A
	BRZ	2B
	
	; MOVE ON TO THE NEXT CHARACTER
	LOAD	B,[MB_PNTR]
	LOAD	C,[CBLOCK]
	LOAD	D,[MB_END]
	
	; INCREMENT
	ADDI	B,1
	CMP	B,D
	BRNZ	0B
	
	; GET THE NEXT BLOCK
4:	STORE	[DBANK],C
	LOADF	C,[D+0-32]
	LOADF	B,[D+1-32]
	LOADI	A,0
	STORE	[DBANK],A
	LOADI	D,32
	ADD	D,B
	ADDI	B,3
	JUMP	0B
	
	
	; RESTORE STACK AND RETURN
8:	LOADI	A,0
9:	LOADI	B,0
	STORE	[DBANK],B
	LOAD	D,[SPARK]
	ADDI	D,2
	JUMP	IRET

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI+1
