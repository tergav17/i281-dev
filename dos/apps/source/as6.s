; AS6.S
; ASSEMBLY INSTRUCTION GENERATION
; GAVIN TERSTEEG, 2024
; SDMAY24-14

BI	= BI+1
.TEXT
.BANK	BI
ISR0_B	= BI

	; OUTPUTS AN INSTRUCTION
	; FIRST, WE MUST FIND WHAT INSTRUCTION HAS BEEN SPECIFIED
DOISR:	LOADI	A,ITAB0_B
	LOADI	C,@+3
0:	STOREF	[D],C
	JUMP	CHKTAB
	ADDI	A,0
	BRNZ	1F
	LOADI	A,ITAB1_B
	LOADI	C,@+2
	JUMP	0B
	ADDI	A,0
	BRNZ	1F
	LOADI	A,ITAB2_B
	LOADI	C,@+2
	JUMP	0B
	ADDI	A,0
	BRNZ	1F
	
	; DIDN'T WORK :(
	LOADI	A,E_UXTOK
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR

	; FOUND IT!!!
1:	STORE	[OPCODE],B
	LOADI	B,ISR1_B
	LOADI	C,DOISRA
	JUMP	INDIR

	; CHECK TABLE
	; A = TABLE TO CHECK
CHKTAB:	STORE	[SPARK],D
	STORE	[DBANK],A
	LOADI	B,ISRTAB0
0:	LOADI	A,0
1:	LOADF	C,[A]
	LOADF	D,[B]
	CMP	C,D
	BRNZ	2F
	ADDI	A,1
	ADDI	B,1
	ADDI	D,0
	BRNZ	1B
	
	; WE MATCH
	LOADF	A,[B]
	LOADF	B,[B+1]
	JUMP	4F
	
	; NO MATCH
	; FIND END OF ENTRY
2:	ADDI	D,0
	BRZ	3F
	ADDI	B,1
	LOADF	D,[B]
	JUMP	2B

	; SKIP TO NEXT ENTRY
3:	ADDI	B,3
	LOADF	D,[B]
	ADDI	D,0
	BRNZ	0B
	
	; INSTRUCTION NOT FOUND
	LOADI	A,0
	LOADI	B,0
	
	; RETURN
4:	LOADI	C,0
	STORE	[DBANK],C
	LOAD	D,[SPARK]
	LOADF	C,[D]
	JUMPR	C
	
	; RETURNS WHAT REGISTER IS CURRENTLY IN THE TOKEN BUFFER
	; AND THEN READS THE NEXT TOKEN
	; WILL ERROR OUT IF IT ISN'T A REGISTER
GETREG:	SUBI	D,2
	LOADI	C,BI
	STOREF	[D+1],C
	
	; MAKE SURE IT IS A SYMBOL
	LOAD	A,[TOKEN]
	SUBI	A,SYMBOL
	BRNZ	9F
	
	; MAKE SURE IT IS ONE CHARACTER LONG
	LOAD	A,[TBUF+1]
	ADDI	A,0
	BRNZ	9F
	
	; CONVERT CHARACTER TO DECIMAL
	LOAD	A,[TBUF]
	SUBI	A,'A'
	LOADI	B,4
	CMP	A,B
	BRAE	9F
	STORE	[TEMP],A

	; GET NEXT TOKEN
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; RETURN
	LOAD	A,[TEMP]
	ADDI	D,2
	JUMP	IRET
	
9:	LOADI	A,E_UXTOK
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
	; SINCE WE AREN'T DEFINING ANYTHING
	; WE CAN RESULT DEFSIZE AS A TEMP VALUE
OPCODE	= DEFSIZE
	
BI	= BI+1
.TEXT
.BANK	BI
ISR1_B	= BI

	; USING INSTRUCTION TYPE, PROCESS INSTRUCTION
DOISRA:	LOADI	C,BI
	STOREF	[D+1],C
	SUBI	A,BASIC
	BRNZ	5F

	; BASIC INSTRUCTION
	; JUST EMIT THE OPCODE
	LOAD	B,[OPCODE]
	STORE	[VALUE],B
	LOADI	A,0
	STORE	[VALUE+1],A
	LOADI	C,7F
IEMITA:	STOREF	[D],C		; SHORTCUT TO EMIT HERE
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR
	
5:	SUBI	A,ARITH-BASIC
	BRNZ	5F

	; ARITHMETIC INSTRUCTION
	; GET A REGISTER
	LOADI	C,@+5
IGETRGA:STOREF	[D],C		; SHORTCUT TO GET REGISTER HERE
	LOADI	B,ISR0_B
	LOADI	C,GETREG
	JUMP	INDIR
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[OPCODE],B
	
	; MAKE SURE WE HAVE A COMMA NEXT
	LOAD	A,[TOKEN]
	SUBI	A,','
	BRNZ	IUXTOKA
	LOADI	C,@+2
	JUMP	INEXTA
	
	; NEXT REGISTER
	LOADI	C,@+2
	JUMP	IGETRGA
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	ADD	B,A
	STORE	[OPCODE],B
	
	; SET [VALUE+1] TO ZERO
	LOADI	A,0
	STORE	[VALUE+1],A
	
	; IS IT A '+'?
	LOAD	A,[TOKEN]
	SUBI	A,'+'
	BRNZ	1F
	LOADI	C,@+2
	JUMP	INEXTA
	
	; EVALUATE EXPRESSION
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	ADDI	A,0
	BRZ	1F
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F
	
1:	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOADI	C,7F
	JUMP	IEMITA
	
	
5:	SUBI	A,IMM-ARITH
	BRNZ	5F
	
	; IMMEDIATE VALUE INSTRUCTION
	; GET THE REGISTER
	LOADI	C,@+2
	JUMP	IGETRGA
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[OPCODE],B
	
	; MAKE SURE WE HAVE A COMMA NEXT
	LOAD	A,[TOKEN]
	SUBI	A,','
	BRNZ	IUXTOKA
	LOADI	C,@+2
	JUMP	INEXTA
	
	; EVALUATE EXPRESSION
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	ADDI	A,0
	BRZ	1F
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F

1:	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOADI	C,7F
	JUMP	IEMITA
	
	; NEXT BANK
5:	LOADI	B,ISR2_B
	LOADI	C,DOISRB
	JUMP	INDIR

	; CONSUME NEXT TOKEN
6:	LOADI	C,@+5
INEXTA:	STOREF	[D],C		; SHORTCUT TO NEXT TOKEN HERE
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; THIS BETTER BE A NEWLINE
7:	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	; NOPE 
IUXTOKA:LOADI	A,E_UXTOK
	JUMP	9F
	
	; DO ANOTHER LINE
8:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	
	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
BI	= BI+1
.TEXT
.BANK	BI
ISR2_B	= BI

	; CONTINUED INSTRUCTION PROCESSING
DOISRB:	LOADI	C,BI
	STOREF	[D+1],C
	SUBI	A,PNT-IMM
	BRNZ	5F

	; SINGLE POINTER INSTRUCTION
	; MAKE SURE WE GET A '['
DOPNT:	LOAD	A,[TOKEN]
	SUBI	A,'['
	BRNZ	IUXTOKB
	LOADI	C,@+2
	JUMP	INEXTB
	
	; EVALUATE EXPRESSION
DOPNTX:	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	ADDI	A,0
	BRZ	1F
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F

1:	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOADI	C,@+5
IEMITB:	STOREF	[D],C		; SHORTCUT TO EMIT HERE
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR
	
	; MAKE SURE WE GET A ']'
DOPNTE:	LOAD	A,[TOKEN]
	SUBI	A,']'
	BRNZ	IUXTOKB
	JUMP	6F
	
5:	SUBI	A,PNTO-PNT
	BRNZ	5F
	
	; POINTER + OFFSET INSTRUCTION
	; MAKE SURE WE GET A '['
	LOAD	A,[TOKEN]
	SUBI	A,'['
	BRNZ	IUXTOKB
	LOADI	C,@+2
	JUMP	INEXTB
	
	; GET A REGISTER
	LOADI	C,@+5
IGETRGB:STOREF	[D],C		; SHORTCUT TO GET REGISTER HERE
	LOADI	B,ISR0_B
	LOADI	C,GETREG
	JUMP	INDIR
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[OPCODE],B
	
	; IS IT A '+'?
DOPNTO:	LOAD	A,[TOKEN]
	SUBI	A,'+'
	BRNZ	1F
	LOADI	C,DOPNTX
	JUMP	INEXTB

	; JUST EMIT AND BE DONE
1:	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOADI	A,0
	STORE	[VALUE+1],A
	LOADI	C,DOPNTE
	JUMP	IEMITB

5:	SUBI	A,MLOAD-PNTO
	BRNZ	5F

	; MEMORY LOAD INSTRUCTION
	; GET A REGISTER
	LOADI	C,@+2
	JUMP	IGETRGB
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[OPCODE],B
	
	; MAKE SURE WE HAVE A COMMA NEXT
	LOAD	A,[TOKEN]
	SUBI	A,','
	BRNZ	IUXTOKB
	LOADI	C,DOPNT
	JUMP	INEXTB

5:	SUBI	A,MLOADF-MLOAD
	BRNZ	5F
	
	; MEMORY LOAD OFFSET INSTRUCTION
	; GET A REGISTER
	LOADI	C,@+2
	JUMP	IGETRGB
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[OPCODE],B
	
	; MAKE SURE WE HAVE A COMMA NEXT
	LOAD	A,[TOKEN]
	SUBI	A,','
	BRNZ	IUXTOKB
	LOADI	C,@+2
	JUMP	INEXTB
	
	; AND A SQUARE BRACKET
	LOAD	A,[TOKEN]
	SUBI	A,'['
	BRNZ	IUXTOKB
	LOADI	C,@+2
	JUMP	INEXTB
	
	; GET A REGISTER
	LOADI	C,@+2
	JUMP	IGETRGB
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	ADD	B,A
	STORE	[OPCODE],B
	JUMP	DOPNTO

	; NEXT BANK
5:	LOADI	B,ISR3_B
	LOADI	C,DOISRC
	JUMP	INDIR

	; CONSUME NEXT TOKEN
6:	LOADI	C,@+5
INEXTB:	STOREF	[D],C		; SHORTCUT TO NEXT TOKEN HERE
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; THIS BETTER BE A NEWLINE
7:	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	; NOPE 
IUXTOKB:LOADI	A,E_UXTOK
	JUMP	9F
	
	; DO ANOTHER LINE
8:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	
	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
BI	= BI+1
.TEXT
.BANK	BI
ISR3_B	= BI

	; CONTINUED INSTRUCTION PROCESSING
DOISRC:	LOADI	C,BI
	STOREF	[D+1],C
	SUBI	A,MSTORE-MLOADF
	BRNZ	5F

	; MEMORY STORE INSTRUCTION
	; MAKE SURE WE GET A '['
	LOAD	A,[TOKEN]
	SUBI	A,'['
	BRNZ	IUXTOKC
	LOADI	C,@+2
	JUMP	INEXTC
	
	; EVALUATE EXPRESSION
DOSTORX:LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	DOSTORE
	ADDI	A,0
	BRZ	DOSTORE
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F
	
	; MAKE SURE WE GET A ']'
DOSTORE:LOAD	A,[TOKEN]
	SUBI	A,']'
	BRNZ	IUXTOKC
	LOADI	C,@+2
	JUMP	INEXTC
	
	; MAKE SURE WE GET A ','
	LOAD	A,[TOKEN]
	SUBI	A,','
	BRNZ	IUXTOKC
	LOADI	C,@+2
	JUMP	INEXTC
	
	; GET A REGISTER
	LOADI	C,@+5
IGETRGC:STOREF	[D],C		; SHORTCUT TO GET REGISTER HERE
	LOADI	B,ISR0_B
	LOADI	C,GETREG
	JUMP	INDIR
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[VALUE],B
	
	; AND EMIT
	LOADI	C,7F
IEMITC:	STOREF	[D],C		; SHORTCUT TO EMIT HERE
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR
	
5:	SUBI	A,MSTOREF-MSTORE
	BRNZ	5F

	; MEMORY STORE OFFSET INSTRUCTION
	; MAKE SURE WE GET A '['
	LOAD	A,[TOKEN]
	SUBI	A,'['
	BRNZ	IUXTOKC
	LOADI	C,@+2
	JUMP	INEXTC
	
	; GET A REGISTER
	LOADI	C,@+2
	JUMP	IGETRGC
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	ADD	B,A
	STORE	[OPCODE],B
	
	; SET [VALUE+1] TO ZERO
	LOADI	A,0
	STORE	[VALUE+1],A
	
	; IS IT A '+'?
	LOAD	A,[TOKEN]
	SUBI	A,'+'
	BRNZ	DOSTORE
	LOADI	C,DOSTORX
	JUMP	INEXTC
	
5:	SUBI	A,SINGLE-MSTOREF
	BRNZ	5F
	
	; SINGLE REGISTER INSTRUCTION
	; GET A REGISTER
	LOADI	C,@+2
	JUMP	IGETRGC
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[VALUE],B
	LOADI	A,0
	STORE	[VALUE+1],A
	
	; AND EMIT
	LOADI	C,7F
	JUMP	IEMITC
	
5:	SUBI	A,BRANCH-SINGLE
	BRNZ	5F
	
	; BRANCH INSTRUCTION
	; EVALUATE EXPRESSION
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	ADDI	A,0
	BRZ	1F
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F
	
	; CORRECT FOR LOCATION
1:	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOAD	A,[COUNTER]
	LOADI	B,0XFF
	SUB	B,A
	LOAD	A,[VALUE+1]
	ADD	A,B
	STORE	[VALUE+1],A
	
	; AND EMIT
	LOADI	C,7F
	JUMP	IEMITC
	
	; NEXT BANK
5:	LOADI	B,ISR4_B
	LOADI	C,DOISRD
	JUMP	INDIR

	; CONSUME NEXT TOKEN
6:	LOADI	C,@+5
INEXTC:	STOREF	[D],C		; SHORTCUT TO NEXT TOKEN HERE
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; THIS BETTER BE A NEWLINE
7:	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	; NOPE 
IUXTOKC:LOADI	A,E_UXTOK
	JUMP	9F
	
	; DO ANOTHER LINE
8:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	
	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
BI	= BI+1
.TEXT
.BANK	BI
ISR4_B	= BI

	; CONTINUED INSTRUCTION PROCESSING
DOISRD:	LOADI	C,BI
	STOREF	[D+1],C
	SUBI	A,PSEUDO-BRANCH
	BRNZ	5F
	
	; PSUEDO INSTRUCTION
	; GET A REGISTER
	LOADI	C,@+5
IGETRGD:STOREF	[D],C		; SHORTCUT TO GET REGISTER HERE
	LOADI	B,ISR0_B
	LOADI	C,GETREG
	JUMP	INDIR
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	MOV	C,A
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	ADD	B,C
	STORE	[VALUE],B
	LOADI	A,0
	STORE	[VALUE+1],A
	
	; AND EMIT
	LOADI	C,7F
IEMITD:	STOREF	[D],C		; SHORTCUT TO EMIT HERE
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR

5:	SUBI	A,BJUMPR-PSEUDO
	BRNZ	5F
	
	; JUMPR INSTRUCTION
	; GET A REGISTER, MAKE SURE IT IS 'C'
	LOADI	C,@+2
	JUMP	IGETRGD
	SUBI	A,2
	BRNZ	IUXTOKD
	STORE	[VALUE+1],A
	
	; IS IT A '+'?
	LOAD	A,[TOKEN]
	SUBI	A,'+'
	BRNZ	1F
	LOADI	C,@+2
	JUMP	INEXTD
	
	; EVALUATE EXPRESSION
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	ADDI	A,0
	BRZ	1F
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F
	
	; EMIT THE OPCODE, CORRECT FOR LOCATION
1:	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOAD	A,[COUNTER]
	LOADI	B,0XFF
	SUB	B,A
	LOAD	A,[VALUE+1]
	ADD	A,B
	STORE	[VALUE+1],A
	
	; AND EMIT
	LOADI	C,7F
	JUMP	IEMITD
	
5:	SUBI	A,MCACHE-BJUMPR
	BRNZ	5F
	
	; CACHE INSTRUCTION
	; GET A REGISTER, MAKE SURE IT IS 'A'
	LOADI	C,@+2
	JUMP	IGETRGD
	ADDI	A,0
	BRNZ	IUXTOKD
	STORE	[VALUE+1],A
	
	; AND EMIT
	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOADI	C,7F
	JUMP	IEMITD

	; NEXT BANK
5:	LOADI	B,ISR5_B
	LOADI	C,DOISRE
	JUMP	INDIR

	; CONSUME NEXT TOKEN
6:	LOADI	C,@+5
INEXTD:	STOREF	[D],C		; SHORTCUT TO NEXT TOKEN HERE
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; THIS BETTER BE A NEWLINE
7:	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	; NOPE 
IUXTOKD:LOADI	A,E_UXTOK
	JUMP	9F
	
	; DO ANOTHER LINE
8:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	
	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	
BI	= BI+1
.TEXT
.BANK	BI
ISR5_B	= BI

	; CONTINUED INSTRUCTION PROCESSING
DOISRE:	LOADI	C,BI
	STOREF	[D+1],C
	SUBI	A,MWRITE-MCACHE
	BRNZ	5F

	; CODE MEMORY WRITE INSTRUCTION
	; MAKE SURE WE GET A '['
	LOAD	A,[TOKEN]
	SUBI	A,'['
	BRNZ	IUXTOKE
	LOADI	C,@+2
	JUMP	INEXTE
	
	; GET A REGISTER
	LOADI	C,@+5
IGETRGE:STOREF	[D],C		; SHORTCUT TO GET REGISTER HERE
	LOADI	B,ISR0_B
	LOADI	C,GETREG
	JUMP	INDIR
	
	; MAKE SURE IT ISN'T 'A'
	ADDI	A,0
	BRZ	IUXTOKE
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[OPCODE],B
	
	; SET [VALUE+1] TO ZERO
	LOADI	A,0
	STORE	[VALUE+1],A
	
	; IS IT A '+'?
	LOAD	A,[TOKEN]
	SUBI	A,'+'
	BRNZ	1F
	LOADI	C,@+2
	JUMP	INEXTE
	
	; EVALUATE EXPRESSION
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	ADDI	A,0
	BRZ	1F
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F
	
	; MAKE SURE WE GET A ']'
1:	LOAD	A,[TOKEN]
	SUBI	A,']'
	BRNZ	IUXTOKE
	LOADI	C,@+2
	JUMP	INEXTE

	; MAKE SURE WE GET A ','
	LOAD	A,[TOKEN]
	SUBI	A,','
	BRNZ	IUXTOKE
	LOADI	C,@+2
	JUMP	INEXTE
	
	; GET A REGISTER, MUST BE A
	LOADI	C,@+2
	JUMP	IGETRGE
	ADDI	A,0
	BRNZ	IUXTOKE
	
	; AND EMIT
	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOADI	C,7F
IEMITE:	STOREF	[D],C		; SHORTCUT TO EMIT HERE
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR
	
5:	SUBI	A,SINGLEI-MWRITE
	BRNZ	IUXTOKE
	
	; SINGLE REGISTER + OFFSET INSTRUCTION
	; GET A REGISTER
	LOADI	C,@+2
	JUMP	IGETRGE
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[OPCODE],B
	
	; SET [VALUE+1] TO ZERO
	LOADI	A,0
	STORE	[VALUE+1],A
	
	; IS IT A '+'?
	LOAD	A,[TOKEN]
	SUBI	A,'+'
	BRNZ	1F
	LOADI	C,@+2
	JUMP	INEXTE
	
	; EVALUATE EXPRESSION
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	ADDI	A,0
	BRZ	1F
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F
	
	; AND EMIT
1:	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOADI	C,7F
	JUMP	IEMITE
	
	; CONSUME NEXT TOKEN
6:	LOADI	C,@+5
INEXTE:	STOREF	[D],C		; SHORTCUT TO NEXT TOKEN HERE
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; THIS BETTER BE A NEWLINE
7:	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	; NOPE 
IUXTOKE:LOADI	A,E_UXTOK
	JUMP	9F
	
	; DO ANOTHER LINE
8:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	
	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	