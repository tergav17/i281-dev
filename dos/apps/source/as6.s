; AS6.S
; ASSEMBLY INSTRUCTION GENERATION
; GAVIN TERSTEEG, 2024
; SDMAY24-14

BI	= BI+1
.TEXT
.BANK	BI
ISR0_B	= BI

	; OUTPUTS AN INSTRUCTION
	; FIRST, WE MUST FIND WHAT INSTRUCTION HAS BEEN SPECIFIED
DOISR:	LOADI	A,ITAB0_B
	LOADI	C,@+3
0:	STOREF	[D],C
	JUMP	CHKTAB
	ADDI	A,0
	BRNZ	1F
	LOADI	A,ITAB1_B
	LOADI	C,@+2
	JUMP	0B
	ADDI	A,0
	BRNZ	1F
	LOADI	A,ITAB2_B
	LOADI	C,@+2
	JUMP	0B
	ADDI	A,0
	BRNZ	1F
	
	; DIDN'T WORK :(
	LOADI	A,E_UXTOK
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR

	; FOUND IT!!!
1:	STORE	[TEMP],B
	LOADI	B,ISR1_B
	LOADI	C,DOISRA
	JUMP	INDIR

	; CHECK TABLE
	; A = TABLE TO CHECK
CHKTAB:	STORE	[SPARK],D
	STORE	[DBANK],A
	LOADI	B,ISRTAB0
0:	LOADI	A,0
1:	LOADF	C,[A]
	LOADF	D,[B]
	CMP	C,D
	BRNZ	2F
	ADDI	A,1
	ADDI	B,1
	ADDI	D,0
	BRNZ	1B
	
	; WE MATCH
	LOADF	A,[B]
	LOADF	B,[B+1]
	JUMP	4F
	
	; NO MATCH
	; FIND END OF ENTRY
2:	ADDI	D,0
	BRZ	3F
	ADDI	B,1
	LOADF	D,[B]
	JUMP	2B

	; SKIP TO NEXT ENTRY
3:	ADDI	B,3
	LOADF	D,[B]
	ADDI	D,0
	BRNZ	0B
	
	; INSTRUCTION NOT FOUND
	LOADI	A,0
	LOADI	B,0
	
	; RETURN
4:	LOADI	C,0
	STORE	[DBANK],C
	LOAD	D,[SPARK]
	LOADF	C,[D]
	JUMPR	C
	
	; RETURNS WHAT REGISTER IS CURRENTLY IN THE TOKEN BUFFER
	; AND THEN READS THE NEXT TOKEN
	; WILL ERROR OUT IF IT ISN'T A REGISTER
GETREG:	SUBI	D,2
	LOADI	C,BI
	STOREF	[D+1],C
	
	; MAKE SURE IT IS A SYMBOL
	LOAD	A,[TOKEN]
	SUBI	A,SYMBOL
	BRNZ	9F
	
	; MAKE SURE IT IS ONE CHARACTER LONG
	LOAD	A,[TBUF+1]
	ADDI	A,0
	BRNZ	9F
	
	; CONVERT CHARACTER TO DECIMAL
	LOAD	A,[TBUF]
	SUBI	A,'A'
	LOADI	B,4
	CMP	A,B
	BRA	9F
	STORE	[TEMP],A

	; GET NEXT TOKEN
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; RETURN
	LOAD	A,[TEMP]
	ADDI	D,2
	JUMP	IRET
	
9:	LOADI	A,E_UXTOK
	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR
	
	; SINCE WE AREN'T DEFINING ANYTHING
	; WE CAN RESULT DEFSIZE AS A TEMP VALUE
OPCODE	= DEFSIZE
	
BI	= BI+1
.TEXT
.BANK	BI
ISR1_B	= BI

	; USING INSTRUCTION TYPE, PROCESS INSTRUCTION
DOISRA:	LOAD	B,[TEMP]
	LOADI	C,BI
	STOREF	[D+1],C
	SUBI	A,BASIC
	BRNZ	5F

	; BASIC INSTRUCTION
	; JUST EMIT THE OPCODE
	STORE	[VALUE],B
	LOADI	A,0
	STORE	[VALUE+1],A
	LOADI	C,7F
IEMITA:	STOREF	[D],C		; SHORTCUT TO EMIT HERE
	LOADI	B,EMIT0_B
	LOADI	C,EMIT
	JUMP	INDIR
	
5:	SUBI	A,ARITH-BASIC
	BRNZ	5F

	; ARITHMETIC INSTRUCTION
	STORE	[OPCODE],B
	
	; GET A REGISTER
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,ISR0_B
	LOADI	C,GETREG
	JUMP	INDIR
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	SHIFTL	A
	SHIFTL	A
	ADD	B,A
	STORE	[OPCODE],B
	
	; MAKE SURE WE HAVE A COMMA NEXT
	LOAD	A,[TOKEN]
	SUBI	A,','
	BRNZ	IUXTOKA
	LOADI	C,@+2
	JUMP	INEXTA
	
	; NEXT REGISTER
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,ISR0_B
	LOADI	C,GETREG
	JUMP	INDIR
	
	; ADD TO OPCODE
	LOAD	B,[OPCODE]
	ADD	B,A
	STORE	[OPCODE],B
	
	; SET [VALUE+1] TO ZERO
	LOADI	A,0
	STORE	[VALUE+1],A
	
	; IS IT A '+'?
	LOAD	A,[TOKEN]
	SUBI	A,'+'
	BRNZ	1F
	LOADI	C,@+2
	JUMP	INEXTA
	
	; EVALUATE EXPRESSION
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,EXP0_B
	LOADI	C,PARSEX
	JUMP	INDIR
	LOAD	B,[PASS]
	ADDI	B,0
	BRZ	1F
	ADDI	A,0
	BRZ	1F
	
	; UNDEFINED EXPRESSION
	LOADI	A,E_UDEFX
	JUMP	9F
	
1:	LOAD	A,[OPCODE]
	STORE	[VALUE],A
	LOADI	C,7F
	JUMP	IEMITA
	

5:	

	; CONSUME NEXT TOKEN
6:	LOADI	C,@+5
INEXTA:	STOREF	[D],C		; SHORTCUT TO NEXT TOKEN HERE
	LOADI	B,TOK0_B
	LOADI	C,NEXTTOK
	JUMP	INDIR

	; THIS BETTER BE A NEWLINE
7:	LOAD	A,[TOKEN]
	ADDI	A,0
	BRZ	8F
	SUBI	A,NEWLINE
	BRZ	8F
	
	; NOPE 
IUXTOKA:LOADI	A,E_UXTOK
	JUMP	9F
	
	; DO ANOTHER LINE
8:	LOADI	B,MAIN0_B
	LOADI	C,ASMLINE
	JUMP	INDIR
	
	; ERROR STUB
9:	LOADI	B,CORE0_B
	LOADI	C,ERROR
	JUMP	INDIR