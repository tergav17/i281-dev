; ALLOC.S
; BLOCK ALLOCATION MANAGEMENT

.BANK BI
AL0_B	= BI
.TEXT

	; FLUSH ANY BUFFERS THAT MAY HAVE BECOME DIRTY
	; ASSUMES WORK BANK IS SELECTED
	; USES: A, B, C, M0
FLUSH:	SUBI	D,2
	LOADI	C,BI
	STOREF	[D+1],C

	; CHECK IF OPEN FILE IS DIRTY
	LOAD	A,[OF_DRTY]
	ADDI	A,0
	BRZ	1F
	
	; RESET OPEN FILE DIRTY FLAG
	LOADI	A,0
	STORE	[OF_DRTY],A
	
	; MOVE FILE SIZE BACK INTO FILE RECORD
	STORE	[M0],D
	LOAD	C,[OF_SIZE]
	LOAD	D,[OF_SIZE+1]
	LOAD	A,[SRCH_RP]
	LOAD	B,[SRCH_BK]
	STORE	[DBANK],B
	STOREF	[A+10],C
	STOREF	[A+11],D
	LOADI	B,WORK_B
	STORE	[DBANK],B
	LOAD	D,[M0]

	; EXECUTE WRITES FOR FILE RECORD AND BTAB
	LOADI	A,0
	LOAD	B,[SRCH_LO]
	STORE	[BLK],A
	STORE	[BLK+1],B
	
	; WRITE FILE RECORD
	LOADI	A,KBUF_B
	LOADI	C,@+5
0:	STOREF	[D],C
	LOADI	B,BLK0_B
	LOADI	C,BLKWRIT
	JUMP	INDIR
	
	; GET ADDRESS OF THE FILE BLOCK TABLE
	LOAD	A,[OF_BTAB]
	LOAD	B,[OF_BTAB+1]
	STORE	[BLK],A
	STORE	[BLK+1],B
	
	; WRITE FILE BLOCK TABLE
	LOADI	A,FBT_B
	LOADI	C,@+2
	JUMP	0B
	
	; CHECK IF ALLOCATION BITMAP IS DIRTY
1:	LOAD	A,[AB_DRTY]
	ADDI	A,0
	BRZ	2F
	
	; RESET ALLOCATION BITMAP DIRTY FLAG
	LOADI	A,0
	STORE	[AB_DRTY],A
	
	; GET ADDRESS OF CURRENT ALLOCATION BITMAP BLOCK
	LOADI	A,0
	LOAD	B,[AB_CBLK]
	STORE	[BLK],A
	STORE	[BLK+1],B

	; WRITE ALLOCATION BITMAP
	LOADI	A,ABM_B
	LOADI	C,@+2
	JUMP	0B

	; RESET STACK AND RETURN
2:	ADDI	D,2
	LOADI	A,WORK_B
	STORE	[DBANK],A
	LOADI	A,0
	JUMP	IRET
	
	; INDEX ALLOCATION BITMAP
	; SEARCHES FOR A BLOCK IN THE ALLOCATION TABLE
	; THAT CONTAINS AN EMPTY BLOCK OR ALLOCATED BLOCK
	; ASSUMES WORK BANK IS SELECTED
	; A = 0 IF LOOKING FOR EMPTY BLOCK, A = 1 IF LOOKING FOR FULL BLOCK
	; A = 0XFF IF COUNTING FREE BLOCKS
	; RETURNS A = 0 IF OPERATION IS SUCCESSFUL, A = 0XFF OTHERWISE
	; USES: A, B, C, M0, M1, M2
INDEX:	LOADI	B,AL1_B
	LOADI	C,INDEXA
	JUMP	INDIR
	
	; ALLOCATE BLOCK ON DISK
	; LOOKS FOR AN UNUSED BLOCK IN THE ALLOCATION BITMAP,
	; RESERVES IT, AND THEN RETURNS IT.
	; ADDRESS WILL BE RETURNED IN [BLK]
	; RETURNS A = 0 IF OPERATION IS SUCCESSFUL, A = 0XFF OTHERWISE
	; USES: A, B, C, M0, M1, M2
ALLOC:	LOADI	B,AL2_B
	LOADI	C,ALLOCA
	JUMP	INDIR
	
	; FREE BLOCK ON DISK
	; GIVEN A BLOCK IN [AB_FREE], THE ABM WILL BE
	; SEARCHED AND THAT BIT WILL BE MARKED AS UNALLOCATED
	; [AB_FREE] = BLOCK TO FREE
	; USES: A, B, C, M0, M1, M2
FREE:	LOADI	B,AL3_B
	LOADI	C,FREEA
	JUMP	INDIR
	
	; FREE A FILE
	; GIVEN AN OPEN FILE, ALL OWNED BLOCKS WILL BE FREED
	; AND ITS FILE RECORD WILL BE MARKED EMPTY
	; USES: A, B, C, M0, M1, M2
FFREE:	LOADI	B,AL4_B
	LOADI	C,FFREEA
	JUMP	INDIR

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI-1
.BANK BI
AL1_B	= BI
.TEXT
	
BD_FREE	= 0X6E
	
	; SHADOW OF INDEX
INDEXA: STORE	[M1],A
	SUBI	D,2

	; DO WE RESET THE BLOCK COUNT?
	ADDI	A,0
	BRNN	0F
	
	; YES, WE DO
	LOADI	A,0
	STORE	[DBANK],A
	STORE	[BD_FREE],A
	STORE	[BD_FREE+1],A
	
	; SWITCH BACK THE WORK BANK AND CONTINUE
	LOADI	A,WORK_B
	STORE	[DBANK],A
	
	; BEFORE WE DO ANY WORK, LETS FLUSH THE EXISTING BUFFERS
0:	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,AL0_B
	LOADI	C,FLUSH
	JUMP	INDIR
	
	; SET CURRENT AB BLOCK TO 1
	LOADI	A,0
	STORE	[BLK],A
	LOADI	A,1
	
	
	; GRAB THE BLOCK AND START PROCESSING
0:	STORE	[AB_CBLK],A
	STORE	[BLK+1],A
	LOADI	A,ABM_B
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,BLK0_B
	LOADI	C,BLKREAD
	JUMP	INDIR
	
	; INIT SEARCH
	LOADI	A,0
	LOADI	B,ABM_B
	
	; SEARCH THE BITMAP
1:	STORE	[AB_CPNT],A
	STORE	[AB_BANK],B
	STORE	[DBANK],B
	LOADF	C,[A]
	LOADI	B,WORK_B
	STORE	[DBANK],B
	
	; GET BEHAVIOR
	LOAD	A,[M1]
	ADDI	A,0
	BRZ	7F
	BRNN	8F
	
	; COUNT BITS IN C
	LOADI	A,0
	STORE	[DBANK],A
	LOADI	B,8
	
	; KEEP POPPING BITS OFF OF C TILL NONE REMAIN
2:	SHIFTL	C
	BRC	3F
	
	; ADD 1 TO COUNT
	ADDI	A,1
	
	; ARE WE DONE?
3:	SUBI	B,1
	BRNZ	2B
	
	; ADD A TO BIT COUNTER
	LOAD	B,[BD_FREE+1]
	ADD	B,A
	STORE	[BD_FREE+1],B
	BRNC	4F
	LOAD	B,[BD_FREE]
	ADDI	B,1
	STORE	[BD_FREE],B
	
	; DONE, BACK TO THE WORK BANK
4:	LOADI	A,WORK_B
	STORE	[DBANK],A
	
	; GET NEXT CHUNK
6:	LOAD	A,[AB_CPNT]
	LOAD	B,[AB_BANK]
	ADDI	A,1
	BRNN	1B
	LOADI	A,0
	ADDI	B,1
	LOADI	C,ABM_B+4
	CMP	B,C
	BRNZ	1B
	
	; READ THE NEXT BLOCK
	LOAD	A,[AB_CBLK]
	ADDI	A,1
	LOADI	B,17
	CMP	A,B
	BRNZ	0B
	
	; WE DIDN'T FIND IT
	; OR WE ARE JUST DONE COUNTING
	; COULD BE EITHER
	LOAD	B,[M1]
	LOADI	A,0xFF
	ADDI	B,0
	BRNN	9F	; NOPE, RIP :(
	
	; YAY, LETS DO IT AGAIN
	LOADI	A,0
	ADDI	D,2
	JUMP	INDEXA
	
	; CHECK TO SEE IF CHUNK HAS AN EMPTY BLOCK
7:	ADDI	C,1
	BRZ	6B
	LOADI	A,0
	JUMP	9F

	; CHECK TO SEE IF CHUNK HAS A FILLED BLOCK
8:	ADDI	C,0
	BRZ	6B
	LOADI	A,0

	; RESTORE STACK
9:	ADDI	D,2

AL1DONE:LOADI	B,WORK_B
	STORE	[DBANK],B
	JUMP	IRET

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI-1
.BANK BI
AL2_B	= BI
.TEXT

	; SHADOW OF ALLOC
ALLOCA:	SUBI	D,2

	; START SEARCH FOR AN EMPTY BIT
0:	LOAD	B,[AB_BANK]
	LOAD	C,[AB_CPNT]
	STORE	[M1],D

	; SEARCH MEMORY BANK
1:	STORE	[DBANK],B

	; CHECK BYTE
2:	LOADF	A,[C]
	ADDI	A,1
	BRNZ	3F
	ADDI	C,1
	BRNN	2B
	
	; MOVE ON TO NEXT BANK
	ADDI	B,1
	LOADI	C,ABM_B+4
	CMP	B,C
	LOADI	C,0
	BRNZ	1B
	
	; AT THIS POINT, JUST RE-INDEX
	LOADI	A,WORK_B
	STORE	[DBANK],A
	LOADI	A,0
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,AL0_B
	LOADI	C,INDEX
	JUMP	INDIR
	STORE	[M1],D
	
	; DID IT WORK?
	ADDI	A,0
	BRNZ	9F
	JUMP	0B

	; WE FOUND ONE
3:	SUBI	A,1
	LOADI	D,WORK_B
	STORE	[DBANK],D
	
	; SAVE BANK AND CPNT
	STORE	[AB_BANK],B
	STORE	[AB_CPNT],C
	
	; GET THE BIT #
	LOADI	D,0
4:	SHIFTR	A
	BRNC	5F
	ADDI	D,1
	JUMP	4B

	; STORE IT AND THEN MASK THE ENTRY IN THE ABM
5:	STORE	[M0],D
	LOADI	A,1
	SUBI	D,1
	BRNC	6F
	SHIFTL	A
	JUMP	5B
6:	STORE	[DBANK],B
	LOADF	D,[C]
	ADD	D,A
	STOREF	[C],D
	LOADI	A,WORK_B
	STORE	[DBANK],A
	
	; SET ABM DIRTY FLAG
	LOADI	A,0XFF
	STORE	[AB_DRTY],A
	
	; CALCULATE WHAT BLOCK # THAT WE JUST ALLOCATED
	LOAD	A,[AB_CBLK]
	SUBI	A,1
	SHIFTL	A
	SHIFTL	A
	SHIFTL	A
	SHIFTL	A
	SUBI	B,ABM_B
	SHIFTL	C
	SHIFTL	B
	SHIFTL	C
	BRNC	0F
	ADDI	B,1
0:	SHIFTL	B
	SHIFTL	C
	BRNC	1F
	ADDI	B,1
1:	ADD	B,A
	LOAD	A,[M0]
	ADD	C,A
	
	; SAVE IN [BLK]
	LOADI	A,0
	STORE	[BLK],B
	STORE	[BLK+1],C
	
	; RESTORE THE STACK
	LOAD	D,[M1]
9:	ADDI	D,2

AL2DONE:LOADI	B,WORK_B
	STORE	[DBANK],B
	JUMP	IRET

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI-1
.BANK BI
AL3_B	= BI
.TEXT

	; SHADOW OF FREE
FREEA:	SUBI	D,2

	; START BY MAKING SURE AB_CBLK IS CORRECT
0:	LOAD	A,[AB_FREE]
	LOAD	B,[AB_CBLK]
	SHIFTR	A
	SHIFTR	A
	SHIFTR	A
	SHIFTR	A
	ADDI	A,1
	CMP	A,B
	BRZ	1F
	
	; NOPE, LET'S FIX THAT
	; START BY FLUSHING
	STORE	[M1],A
	LOADI	C,BI
	STOREF	[D+1],C
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,AL0_B
	LOADI	C,FLUSH
	JUMP	INDIR
	
	; READ THE CORRECT AB_CBLK
	LOAD	A,[M1]
	STORE	[BLK+1],A
	STORE	[AB_CBLK],A
	LOADI	A,0
	STORE	[BLK],A
	LOADI	A,ABM_B
	LOADI	C,0B
	STOREF	[D],C
	LOADI	B,BLK0_B
	LOADI	C,BLKREAD
	JUMP	INDIR
	
	; ALL GOOD, NOW LETS GET THE BANK / POINTER / BIT
1:	STORE	[M1],D
	LOAD	A,[AB_FREE]
	LOAD	B,[AB_FREE+1]
	
	; FIRST GET THE BIT
	LOADI	C,0
	LOADI	D,3
0:	SHIFTR	C
	SHIFTR	B
	BRNC	1F
	ADDI	C,0X04
1:	SHIFTR	A
	BRNC	2F
	ADDI	B,0X80
2:	SUBI	D,1
	BRNZ	0B
	STORE	[AB_BIT],C
	
	; THEN GET THE POINTER
	LOADI	C,0
	LOADI	D,7
0:	SHIFTR	C
	SHIFTR	B
	BRNC	1F
	ADDI	C,0X40
1:	SHIFTR	A
	BRNC	2F
	ADDI	B,0X80
2:	SUBI	D,1
	BRNZ	0B
	STORE	[AB_CPNT],C
	
	; WE SHOULD BE LEFT WITH THE CORRECT BANK TOO
	ADDI	B,ABM_B
	STORE	[AB_BANK],B
	
	; LETS GO MAKE SURE THAT WE CAN ACTUALLY FREE THIS BLOCK
	LOAD	A,[AB_BIT]
	STORE	[DBANK],B
	LOADF	D,[C]
0:	SUBI	A,1
	BRNC	1F
	SHIFTR	D
	JUMP	0B
1:	SHIFTR	D
	LOADI	D,WORK_B
	STORE	[DBANK],D

	; IF IT'S ZERO, WE CAN EXIT RIGHT NOW
	BRNC	9F
	
	; SET ABM DIRTY FLAG
	LOADI	A,0XFF
	STORE	[AB_DRTY],A
	
	; ALRIGHT, LETS GO DEALLOCATE IT
	LOAD	A,[AB_BIT]
	LOADI	D,1
0:	SUBI	A,1
	BRNC	1F
	SHIFTL	D
	JUMP	0B
1:	STORE	[DBANK],B
	LOADF	A,[C]
	SUB	A,D
	STOREF	[C],A
	LOADI	A,WORK_B
	STORE	[DBANK],A

	; RESTORE THE STACK
9:	LOAD	D,[M1]
	ADDI	D,2

AL3DONE:LOADI	B,WORK_B
	STORE	[DBANK],B
	JUMP	IRET
	
	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI-1
.BANK BI
AL4_B	= BI
.TEXT

	; SHADOW OF FFREE
FFREEA:	SUBI	D,2

	; SET RETURN BANK
	LOADI	C,BI
	STOREF	[D+1],C

	; START BY FREEING ALL FILE CONTENT BLOCKS IN BTAB
0:	LOAD	A,[OF_SIZE+1]
	SUBI	A,1
	STORE	[OF_SIZE+1],A
	BRC	1F
	LOAD	A,[OF_SIZE]
	SUBI	A,1
	STORE	[OF_SIZE],A
	BRNC	4F

	; FREE BLOCK POINTED TO BY [OF_SIZE]
1:	LOAD	A,[OF_SIZE+1]
	LOADI	B,FBT_B
	SHIFTL	A
	BRNC	2F
	ADDI	B,2
2:	SHIFTL	A
	BRNC	3F
	ADDI	B,1
3:	SHIFTR	A
	
	; GET THE BLOCK
	STORE	[M0],D
	STORE	[DBANK],B
	LOADF	C,[A+0]
	LOADF	D,[A+1]
	LOADI	B,WORK_B
	STORE	[DBANK],B
	STORE	[AB_FREE],C
	STORE	[AB_FREE+1],D	
	LOAD	D,[M0]
	
	; CALL FREE
	LOADI	C,0B
	STOREF	[D],C
	LOADI	B,AL0_B
	LOADI	C,FREE
	JUMP	INDIR

	; NEXT, WE FREE THE BLOCK TABLE ITSELF
4:	LOAD	A,[OF_BTAB]
	LOAD	B,[OF_BTAB+1]
	STORE	[AB_FREE],A
	STORE	[AB_FREE+1],B	
	
	; CALL FREE
	LOADI	C,@+5
	STOREF	[D],C
	LOADI	B,AL0_B
	LOADI	C,FREE
	JUMP	INDIR
	
	; FINALLY, WE STRIKE OUT THE FILE RECORD
	LOAD	A,[SRCH_RP]
	LOAD	B,[SRCH_BK]
	LOADI	C,0
	STORE	[DBANK],B
	STOREF	[A],C
	LOADI	B,WORK_B
	STORE	[DBANK],B
	
	; RESET OPEN FILE FLAG
	LOADI	A,0
	STORE	[OF_OPEN],A

	; SET THE FILE DIRTY FLAG
	LOADI	A,0XFF
	STORE	[OF_DRTY],A

	; RESTORE THE STACK
	ADDI	D,2
	
	; DO ONE FINAL FLUSH
	LOADI	B,AL0_B
	LOADI	C,FLUSH
	JUMP	INDIR

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI-1
