; ALLOC.S
; BLOCK ALLOCATION MANAGEMENT

.BANK BI
ALC0_B	= BI
.TEXT

	; FLUSH ANY BUFFERS THAT MAY HAVE BECOME DIRTY
	; ASSUMES WORK BANK IS SELECTED
	; USES: A, B, C, M0
FLUSH:	SUBI	D,2
	LOADI	C,BI
	STOREF	[D+1],C

	; CHECK IF OPEN FILE IS DIRTY
	LOAD	A,[OF_DRTY]
	ADDI	A,0
	BRZ	1F
	
	; RESET OPEN FILE DIRTY FLAG
	LOADI	A,0
	STORE	[OF_DRTY],A
	
	; MOVE FILE SIZE BACK INTO FILE RECORD
	STORE	[M0],D
	LOAD	C,[OF_SIZE]
	LOAD	D,[OF_SIZE+1]
	LOAD	A,[SRCH_RP]
	LOAD	B,[SRCH_BK]
	STORE	[DBANK],B
	STOREF	[A+10],C
	STOREF	[A+11],D
	LOADI	B,WORK_B
	STORE	[DBANK],B
	LOAD	D,[M0]

	; EXECUTE WRITES FOR FILE RECORD AND BTAB
	LOADI	A,0
	LOAD	B,[SRCH_LO]
	STORE	[BLK],A
	STORE	[BLK+1],B
	
	; WRITE FILE RECORD
	LOADI	A,KBUF_B
	LOADI	C,@+5
0:	STOREF	[D],C
	LOADI	B,BLK0_B
	LOADI	C,BLKWRIT
	JUMP	INDIR
	
	; GET ADDRESS OF THE FILE BLOCK TABLE
	LOAD	A,[OF_BTAB]
	LOAD	B,[OF_BTAB+1]
	STORE	[BLK],A
	STORE	[BLK+1],B
	
	; WRITE FILE BLOCK TABLE
	LOADI	A,FBT_B
	LOADI	C,@+2
	JUMP	0B
	
	; CHECK IF ALLOCATION BITMAP IS DIRTY
1:	LOAD	A,[AB_DRTY]
	ADDI	A,0
	BRZ	2F
	
	; RESET ALLOCATION BITMAP DIRTY FLAG
	LOADI	A,0
	STORE	[AB_DRTY],A
	
	; GET ADDRESS OF CURRENT ALLOCATION BITMAP BLOCK
	LOADI	A,0
	LOAD	B,[AB_CBLK]
	STORE	[BLK],A
	STORE	[BLK+1],B

	; WRITE ALLOCATION BITMAP
	LOADI	A,ABM_B
	LOADI	C,@+2
	JUMP	0B

	; RESET STACK AND RETURN
2:	ADDI	D,2
	LOADI	A,WORK_B
	STORE	[DBANK],A
	JUMP	IRET
	
	; INDEX ALLOCATION BITMAP
	; SEARCHES FOR A BLOCK IN THE ALLOCATION TABLE
	; THAT CONTAINS AN EMPTY BLOCK OR ALLOCATED BLOCK
	; ASSUMES WORK BANK IS SELECTED
	; A = 0 IF LOOKING FOR EMPTY BLOCK, A = 1 IF LOOKING FOR FULL BLOCK
	; USES: A, B, C, M0, M1
AINDEX:	LOADI	B,ALC1_B
	LOAD	C,AINDEXA
	JUMP	INDIR

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI-1
.BANK BI
ALC1_B	= BI
.TEXT
	
	; SHADOW OF AINDEX
AINDEXA:STORE	[M1],A
	SUBI	D,2
	
	
	ADDI	D,2


AL0DONE:LOADI	B,WORK_B
	STORE	[DBANK],B
	JUMP	IRET

	; BANK IS DONE, MOVE ON TO THE NEXT
BI	= BI-1
