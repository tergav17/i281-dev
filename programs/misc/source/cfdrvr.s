; CFDRVR.S
; COMPACT FLASH DRIVER PROGRAM FOR MONITOR
; GAVIN TERSTEEG, 2024
; SDMAY24-14

; DEFINES
DBANK	= 0X80		; DATA BANK ADDRESS 

UART	= 0X90		; UART BASE ADDRESS
UART_RH	= UART+0X00	; UART READ HOLDING
UART_TH	= UART+0X00	; UART TRANSMIT HOLDING
UART_DL = UART+0X00	; UART DIVISOR LOW
UART_DH = UART+0X01	; UART DIVISOR HIGH
UART_LC = UART+0X03	; UART LINE CONTROL
UART_LS	= UART+0X05	; UART LINE STATUS
SCRATCH	= UART+0X07	; SCRATCH BYTE ADDRESS

CF	= 0XA0		; COMPACT FLASH BASE ADDRESS
CF_DATA	= CF+0X00	; CF DATA
CF_ERR	= CF+0X01	; CF ERROR
CF_FEAT	= CF+0x01	; CF FEATURES
CF_CNT	= CF+0X02	; CF SECTOR COUNT
CF_LBA0	= CF+0X03	; CF LBA BITS 0-7
CF_LBA1	= CF+0X04	; CF LBA BITS 8-15
CF_LBA2	= CF+0X05	; CF LBA BITS 16-23
CF_LBA3	= CF+0X06	; CF LBA BITS 24-27
CF_STAT	= CF+0X07	; CF STATUS
CF_CMD	= CF+0X07	; CF COMMAND

CF_8BIT	= 0X01		; 8 BIT MODE
CF_DCAC	= 0X82		; DISABLE CACHE

CF_READ	= 0X20		; READ COMMAND
CF_SETF	= 0XEF		; SET FEATURE COMMAND

RETURN	= 0X00		; MONITOR RETURN VECTOR

	; AVAILABLE COMMANDS TO MONITOR
	; 0X80: FILL PATTERN #1
	; 0X81: FILL PATTERN #2
	; 0X82: DUMP BUFFER
	; 0X83: STREAM COMPACT FLASH TO BUFFER
	; 0X84: STREAM BUFFER TO COMPACT FLASH
	

	; JUMP TABLE
	JUMP	FILL1
	JUMP	FILL2
	JUMP	DUMP
	JUMP	CFREAD
	JUMP	CFWRITE
	
	; FILLS UP THE FIRST 4 BANKS WITH A TEST PATTERN (PATTERN 1)
FILL1:	LOADI	A,0
	LOADI	C,4
0:	SUBI	C,1
	BRNC	RETURN
	STORE	[DBANK],C
	LOADI	B,0
1:	STOREF	[B],A
	ADDI	A,1
	ADDI	B,1
	BRNN	1B
	JUMP	0B
	
	; FILLS UP THE FIRST 4 BANKS WITH A TEST PATTERN (PATTERN 2)
FILL2:	LOADI	A,0XFF
	LOADI	C,4
0:	SUBI	C,1
	BRNC	RETURN
	STORE	[DBANK],C
	LOADI	B,0
1:	STOREF	[B],A
	SUBI	A,1
	ADDI	B,1
	BRNN	1B
	JUMP	0B
	
	; FILLS UP THE FIRST 4 BANKS WITH DATA FROM THE COMPACT FLASH
CFREAD:	LOADI	C,0-4
0:	ADDI	C,4
	STORE	[DBANK],C
	LOADI	B,0
1:	LOAD	A,[CF_DATA]
	STOREF	[B],A
	ADDI	B,1
	BRNN	1B
	SUBI	C,3
	BRNZ	0B
	JUMP	RETURN


	; WRITE 4 BANKS OF DATA TO THE COMPACT FLASH
CFWRITE:LOADI	C,0-4
0:	ADDI	C,4
	STORE	[DBANK],C
	LOADI	B,0
1:	LOADF	A,[B]
	STORE	[CF_DATA],A
	ADDI	B,1
	BRNN	1B
	SUBI	C,3
	BRNZ	0B
	JUMP	RETURN

	; DUMPS THE CONTENT OF THE BUFFER ONTO THE TERMINAL
DUMP:	LOADI	A,0
	LOADI	B,0
	
	; DO WE NEED TO PRINT A CRLF?
DLOOP:	MOV	C,A
	SHIFTR	C
	BRC	PRHEX
	SHIFTR	C
	BRC	PRHEX
	SHIFTR	C
	BRC	PRHEX
	SHIFTR	C
	BRC	PRHEX
	
	; PRINT THE LINE FEED
	LOADI	C,@+2
	JUMP	UWAIT
	LOADI	C,0X0A
	STORE	[UART_TH],C
	
	; PRINT THE CARRIAGE RETURN
	LOADI	C,@+2
	JUMP	UWAIT
	LOADI	C,0X0D
	STORE	[UART_TH],C
	
	; PRINT THE HEX
	; WAIT FOR UART TO READY
PRHEX:	LOADI	C,@+2
	JUMP	UWAIT
	
	; GET THE BYTE
	STORE	[DBANK],B
	LOADF	D,[A]

	; PRINT FIRST NYBBLE
	LOADI	C,0XF0

	; SHIFT LAST 4 BITS OF D INTO FIRST 4 BITS OF A
0:	SHIFTL	D
	BRC	1F
	SHIFTL	C
	BRN	0B
	JUMP	2F
1:	SHIFTL	C
	ADDI	C,1
	BRN	0B
	
	; CONVERT TO ASCII 0..9 / A..F
2:	SUBI	C,10
	BRN	3F
	ADDI	C,'A'-('0'+10)
3:	ADDI	C,'0'+10
	STORE	[UART_TH],C
	
	; WAIT FOR UART TO READY
0:	LOAD	C,[UART_LS]
	SHIFTL	C
	SHIFTL	C
	SHIFTL	C
	BRNC	0B

	; PRINT FIRST NYBBLE
	LOADI	C,0XF0

	; SHIFT LAST 4 BITS OF D INTO FIRST 4 BITS OF A
0:	SHIFTL	D
	BRC	1F
	SHIFTL	C
	BRN	0B
	JUMP	2F
1:	SHIFTL	C
	ADDI	C,1
	BRN	0B
	
	; CONVERT TO ASCII 0..9 / A..F
2:	SUBI	C,10
	BRN	3F
	ADDI	C,'A'-('0'+10)
3:	ADDI	C,'0'+10
	STORE	[UART_TH],C

	; INCREMENT POINTER
	ADDI	A,1
	BRNN	DLOOP
	LOADI	A,4
	ADDI	B,1
	CMP	A,B
	LOADI	A,0
	BRNZ	DLOOP
	JUMP	RETURN
	
	; WAIT FOR THE UART TO BECOME READY
	; USES: D
UWAIT:	LOAD	D,[UART_LS]
	SHIFTL	D
	SHIFTL	D
	SHIFTL	D
	BRNC	UWAIT
	JUMPR	C