00/00:          ; BIOS.S
01/00:          ; STANDARD BIOS FOR COMPACT FLASH BOOT
01/00:          ; PLUS STANDARD CALLS
01/00:          ; GAVIN TERSTEEG, 2024
01/00:          ; SDMAY24-14
01/00:          
01/00:          ; DEFINES
01/00:          DBANK	= 0X80		; DATA BANK ADDRESS 
01/00:          
01/00:          UART	= 0X90		; UART BASE ADDRESS
01/00:          UART_RH	= UART+0X00	; UART READ HOLDING
01/00:          UART_TH	= UART+0X00	; UART TRANSMIT HOLDING
01/00:          UART_DL = UART+0X00	; UART DIVISOR LOW
01/00:          UART_DH = UART+0X01	; UART DIVISOR HIGH
01/00:          UART_LC = UART+0X03	; UART LINE CONTROL
01/00:          UART_LS	= UART+0X05	; UART LINE STATUS
01/00:          SCRATCH	= UART+0X07	; SCRATCH BYTE ADDRESS
01/00:          
01/00:          CF	= 0XA0		; COMPACT FLASH BASE ADDRESS
01/00:          CF_DATA	= CF+0X00	; CF DATA
01/00:          CF_ERR	= CF+0X01	; CF ERROR
01/00:          CF_FEAT	= CF+0x01	; CF FEATURES
01/00:          CF_CNT	= CF+0X02	; CF SECTOR COUNT
01/00:          CF_LBA0	= CF+0X03	; CF LBA BITS 0-7
01/00:          CF_LBA1	= CF+0X04	; CF LBA BITS 8-15
01/00:          CF_LBA2	= CF+0X05	; CF LBA BITS 16-23
01/00:          CF_LBA3	= CF+0X06	; CF LBA BITS 24-27
01/00:          CF_STAT	= CF+0X07	; CF STATUS
01/00:          CF_CMD	= CF+0X07	; CF COMMAND
01/00:          
01/00:          CF_8BIT	= 0X01		; 8 BIT MODE
01/00:          CF_DCAC	= 0X82		; DISABLE CACHE
01/00:          
01/00:          CF_READ	= 0X20		; READ COMMAND
01/00:          CF_SETF	= 0XEF		; SET FEATURE COMMAND
01/00:          
01/00:          .BANK 0
00/00:          .TEXT
00/00:          
00/00:          	; BIOS CALL JUMP TABLE
00/00: FF0B     	JUMP	BOOT	; 0: BOOT OPERATION
00/01: FF38     	JUMP	ALTBOOT	; 1: ALT BOOT OPERATION
00/02: FF53     	JUMP	INDIR	; 2: INDIRECT JUMP
00/03: FF56     	JUMP	IRET	; 3: INDIRECT RETURN
00/04: FF59     	JUMP	SYSCALL	; 4: SYSTEM CALL (JUMP TO BANK 0 ADDRESS 0X80, SAVE REGISTER C)
00/05: FF59     	JUMP	SYSJUMP	; 5: SYSTEM JUMP (JUMP TO BANK 0 ADDRESS 0X80, DO NOT SAVE C)
00/06: FF5B     	JUMP	PRGM	; 6: PROGRAM 128 INSTRUCTIONS FROM DMEM
00/07: FF50     	JUMP	IWRITE	; 7: INDIRECT WRITE
00/09:          			; 8: ZSTART
00/08:          			
00/08:          	; PREPARES TO EXECUTE A LEGACY PROGRAM
00/08:          	; SETS BANK TO 1 AND JUMPS TO 0X7F
00/08:          	; ONLY REGISTER A IS USED, AND IT WILL BE SET TO 0 ON JUMP
00/08:          	; IT'S A BIT ODD, BUT IT EXISTS SO WE CAN RESET ALL
00/08:          	; OF THE REGISTERS TO 0, PREPARE TO EXECUTE A PROGRAM, AND
00/08:          	; THEN HALT SO A USER CAN SINGLE STEP THE PROGRAM IF THEY WANT
00/08:          	; USES: A
00/08: 3001     ZSTART:	LOADI	A,1
00/09: 0000     	BANK	A
00/0A: 3000     	LOADI	A,0
00/0B: FF73     	JUMP	HALT
00/0D:          	
00/0C:          	; KICK OFF THE BOOT SEQUENCE
00/0C:          	
00/0C:          	; WE MUST WAIT FOR THE CF TO BE READY BEFORE SENDING A COMMAND
00/0C: 380E     BOOT:	LOADI	C,@+2
00/0D: FF17     	JUMP	CFWAIT
00/0F:          
00/0E:          	; THE TOP 3 BITS OF LBA3 MUST BE '1' TO INDICATE LBA MODE
00/0E: 30E0     	LOADI	A,0XE0
00/0F: A0A6     	STORE	[CF_LBA3],A
00/11:          
00/10:          	; START BY SETTING THE CARD TO 8-BIT MODE
00/10: 3812     	LOADI	C,@+2
00/11: FF13     	JUMP	CFWAIT
00/12: 3001     	LOADI	A,CF_8BIT
00/13: A0A1     	STORE	[CF_FEAT],A
00/14: 30EF     	LOADI	A,CF_SETF
00/15: A0A7     	STORE	[CF_CMD],A
00/17:          	
00/16:          	; NOW DISABLE THE CACHE
00/16: 3818     	LOADI	C,@+2
00/17: FF0D     	JUMP	CFWAIT
00/19:          	;LOADI	A,CF_DCAC
00/18:          	;STORE	[CF_FEAT],A
00/18:          	;LOADI	A,CF_SETF
00/18:          	;STORE	[CF_CMD],A
00/18:          	
00/18:          	; PUNCH IN THE ADDRESS OF THE MBR
00/18:          	; (MASTER BOOT RECORD)
00/18: 3400     	LOADI	B,0
00/19: A4A3     	STORE	[CF_LBA0],B
00/1A: A4A4     	STORE	[CF_LBA1],B
00/1B: A4A5     	STORE	[CF_LBA2],B
00/1D:          	
00/1C:          	; PUT A '1' IN THE SECTOR COUNT REGISTER
00/1C: 3001     	LOADI	A,0X01
00/1D: A0A2     	STORE	[CF_CNT],A
00/1F:          	
00/1E:          	; SINCE A = 1, LETS SET THE DESTINATION BANKS TOO
00/1E: 0000     	BANK	A
00/1F: A080     	STORE	[DBANK],A
00/21:          	
00/20:          	; ISSUE A READ COMMAND!
00/20: 3822     	LOADI	C,@+2
00/21: FF03     	JUMP	CFWAIT
00/22: 3020     	LOADI	A,CF_READ
00/23: A0A7     	STORE	[CF_CMD],A
00/25:          	
00/24:          	; ...AND WAIT FOR IT TO FINISH
00/24: 382B     	LOADI	C,CFBOOT
00/26:          
00/25:          	; WAIT FOR THE CF CARD TO BECOME READY
00/25:          	; FOR THIS TO HAPPEN, THE BUSY FLAG MUST BE 0
00/25:          	; AND THE READY FLAG MUST BE 1
00/25:          	; IF A CF CARD ISN'T PRESENT, THIS ROUTINE HANGS
00/25:          	; BUT WE DON'T CARE
00/25:          	; USES: A
00/25: 80A7     CFWAIT:	LOAD	A,[CF_STAT]
00/27:          
00/26:          	; CHECK BIT 7 (BUSY FLAG)
00/26: 4000     	SHIFTL	A
00/28:          	
00/27:          	; GO BACK TO START BUSY
00/27: F0FD     	BRC	CFWAIT
00/29:          	
00/28:          	; CHECK BIT 6 (READY FLAG)
00/28: 4000     	SHIFTL	A
00/2A:          	
00/29:          	; GO BACK TO START IF NOT READY
00/29: F1FB     	BRNC	CFWAIT
00/2B:          	
00/2A:          	; RETURN FROM FUNCTION CALL
00/2A: FED5     	JUMPR	C
00/2C:          	
00/2B:          	; NOW THE CARD SHOULD BE READY TO SEND BYTES
00/2B:          	; WE ARE JUST GOING TO GO OUT ON A LIMB AND
00/2B:          	; ASSUME THAT WHATEVER MASTER BOOT RECORD
00/2B:          	; WE HAVE BEEN GIVEN IS VALID
00/2B:          	; NO USE IN WASTING PRECIOUS INSTRUCTION MEMORY HERE
00/2B:          	; SKIP THE FIRST 128 BYTES OF MEMORY
00/2B:          	; B SHOULD STILL BE 0 FROM LOADING THE MBR ADDRESS
00/2B: 80A0     CFBOOT:	LOAD	A,[CF_DATA]
00/2C: 5401     	ADDI	B,1
00/2D: F5FD     	BRNN	CFBOOT
00/2F:          	
00/2E:          	; NOW WE UNPACK THE DATA SEGMENT
00/2E: 3400     	LOADI	B,0
00/2F: 80A0     0:	LOAD	A,[CF_DATA]
00/30: B100     	STOREF	[B],A
00/31: 5401     	ADDI	B,1
00/32: F5FC     	BRNN	0B
00/34:          	
00/33:          	; FINALLY, WE DO THE INSTRUCTION SEGMENT
00/33: 80A0     1:	LOAD	A,[CF_DATA]
00/34: 1400     	CACHE	A
00/35: 80A0     	LOAD	A,[CF_DATA]
00/36: 1600     	WRITE	[B],A
00/37: 5401     	ADDI	B,1
00/38: F4FA     	BRN	1B
00/3A:          	
00/39:          	; NOW WE JUMP TO THE LOADED PROGRAM AND HOPE FOR THE BEST!
00/39: FF46     	JUMP	0X80
00/3B:          	
00/3A:          	; UART BOOTSTRAP
00/3A:          	; STARTS THE MACHINE UP FROM A "VIRTUAL PAPER TAPE"
00/3A:          	; FIRST 512 BYTES WILL BE READ AS A SAV RECORD
00/3A:          	; AND PLACED INTO MEMORY
00/3A:          	; AFTER THE 512TH BYTE IS READ, THE LOADED PROGRAM
00/3A:          	; WILL BE EXECUTED
00/3A:          	; DUE TO DIFFERENCES IN EXPECTED BOOT PROCESS, THE DESTINATION
00/3A:          	; BANK IS 0 INSTEAD OF 1. ONLY THE TEXT SECTION WILL BE LOADED
00/3A:          	; A MORE INTELLIGENT LOADER SHOULD THEN BE USED
00/3A:          	; START BY CLEANING OUT THE RH REGISTER
00/3A: 8090     ALTBOOT:LOAD	A,[UART_RH]
00/3C:          
00/3B:          	; SET DLAB
00/3B: 3080     	LOADI	A,0X80
00/3C: A093     	STORE	[UART_LC],A
00/3E:          	
00/3D:          	; DIVISOR = 12
00/3D: 300C     	LOADI	A,12
00/3E: A090     	STORE	[UART_DL],A
00/3F: 3400     	LOADI	B,0
00/40: A491     	STORE	[UART_DH],B
00/42:          	
00/41:          	; SET 8-BIT, 1 STOP, RESET DLAB
00/41: 3003     	LOADI	A,0X03
00/42: A093     	STORE	[UART_LC],A
00/44:          	
00/43:          	; SET BANK
00/43: 0400     	BANK	B
00/45:          	
00/44:          	; SKIP 256 BYTES
00/44: 3846     0:	LOADI	C,@+2
00/45: FF0B     	JUMP	GETC
00/46: 5401     	ADDI	B,1
00/47: F7FC     	BRNZ	0B
00/49:          	
00/48:          	; LOAD TEXT SEGMENT
00/48: 384A     1:	LOADI	C,@+2
00/49: FF07     	JUMP	GETC
00/4A: 1400     	CACHE	A
00/4B: 384D     	LOADI	C,@+2
00/4C: FF04     	JUMP	GETC
00/4D: 1680     	WRITE	[B+0X80],A
00/4E: 5401     	ADDI	B,1
00/4F: F5F8     	BRNN	1B
00/51:          	
00/50:          	; NOW WE JUMP TO THE LOADED PROGRAM AND HOPE FOR THE BEST!
00/50: FF2F     	JUMP	0X80
00/52:          	
00/51:          	
00/51:          	; READ A CHARACTER FROM THE UART
00/51: 8095     GETC:	LOAD	A,[UART_LS]
00/52: C100     	SHIFTR	A
00/53: F1FD     	BRNC	GETC
00/54: 8090     	LOAD	A,[UART_RH]
00/55: FEAA     	JUMPR	C
00/57:          	
00/56:          	; INDIRECT JUMP
00/56:          	; JUMPS TO A SPECIFIC ADDRESS ON A SPECIFIC BANK
00/56:          	; B = DESTINATION ISR BANK
00/56:          	; C = DESTINATION ADDRESS
00/56:          	; USES: NONE
00/56: 0400     INDIR:	BANK	B
00/57: FEA8     	JUMPR	C
00/59:          	
00/58:          	; INDIRECT WRITE
00/58:          	; PERFORMS A WRITE OPERATION ON A SPECIFIC IBANK
00/58:          	; AN INDIRECT RETURN WILL BE EXECUTED AFTER
00/58:          	; A = LOWER VALUE TO WRITE
00/58:          	; B = DESTINATION ADDRESS
00/58:          	; C = DESTINATION ISR BANK
00/58:          	; USES: C
00/58: 0800     IWRITE:	BANK	C
00/59: 1600     	WRITE	[B],A
00/5B:          	
00/5A:          	; INDIRECT RETURN
00/5A:          	; JUMPS TO A BANK / ADDRESS PAIR FOUND IN THE STACK
00/5A:          	; [D] = RETURN ADDRESS
00/5A:          	; [D+1] = RETURN ISR BANK
00/5A:          	; USES: C
00/5A: 9B01     IRET:	LOADF	C,[D+1]
00/5B: 0800     	BANK	C
00/5C: 9B00     	LOADF	C,[D]
00/5D: FEA2     	JUMPR	C
00/5F:          	
00/5E:          	; SYSTEM CALL
00/5E:          	; JUMPS TO ADDRESS 0X80 ON ISR BANK 0
00/5E:          	; USES: C
00/5E: BB00     SYSCALL:STOREF	[D],C
00/5F: 3800     SYSJUMP:LOADI	C,0
00/60: 0800     	BANK	C
00/61: FF1E     	JUMP	0X80
00/63:          
00/62:          	; THIS ROUTINE WILL TAKE 2 BANK FROM DATA MEMORY
00/62:          	; AND WRITE THEM INTO 1 BANK OF INSTRUCTION MEMORY
00/62:          	; RETURNS WITH DATA BANK ON 0
00/62:          	; A = DESTINATION ISR BANK
00/62:          	; B = SOURCE DATA BANK
00/62:          	; C = RETURN ADDRESS
00/62:          	; D = RETURN ISR BANK
00/62:          	; USES: BYTE 0X7E-0X7F OF BANK 0, A, B, C, D
00/62: 0000     PRGM:	BANK	A
00/63: 3000     	LOADI	A,0
00/64: A080     	STORE	[DBANK],A
00/65: A87E     	STORE	[0X7E],C
00/66: AC7F     	STORE	[0X7F],D
00/68:          	
00/67:          	; COPY OVER THE DATA
00/67:          	; CRAZY REGISTER SHIT
00/67: 3C80     	LOADI	D,0X80
00/68: A480     0:	STORE	[DBANK],B
00/69: 3800     	LOADI	C,0
00/6A: 9200     1:	LOADF	A,[C]
00/6B: 1400     	CACHE	A
00/6C: 9201     	LOADF	A,[C+1]
00/6D: C900     	SHIFTR	C
00/6E: 4B00     	ADD	C,D
00/6F: 1A00     	WRITE	[C],A
00/70: 6B00     	SUB	C,D
00/71: 4A00     	SHIFTL	C
00/72: 5802     	ADDI	C,2
00/73: F5F6     	BRNN	1B
00/75:          	
00/74:          	; WE REACHED THE END OF A DATA BANK
00/74:          	; MOVE ON TO THE NEXT?
00/74: 5401     	ADDI	B,1
00/75: 5C40     	ADDI	D,0X40
00/76: F4F1     	BRN	0B
00/78:          	
00/77:          	; NOPE, WE ARE DONE
00/77: 3000     	LOADI	A,0
00/78: A080     	STORE	[DBANK],A
00/79: 887E     	LOAD	C,[0X7E]
00/7A: 8C7F     	LOAD	D,[0X7F]
00/7B: 0C00     	BANK	D
00/7C: FE83     	JUMPR	C
00/7E:          
00/7D:          	; HALT AT THE END OF THE ROM
00/7D:          .ORG	0x7F
00/7F: FFFF     HALT:	JUMP	HALT
00/81:          
